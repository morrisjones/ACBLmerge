#!/usr/bin/perl
#
# Matthew J. Kidd (San Diego, CA)
#
# This software is released under the GNU General Public License GPLv3
# See: http://www.gnu.org/licenses/gpl.html for full license.
#
# ACBLmerge.pl - Merges bridge hands with ACBLscore results
#   - ACBL results need to be in the traveler format. From within ACBLscore
#     navigate: Reports (menu) --> Recap/Press (menu) > Screen/File (LR) -->
#     2. File --> 8. Press + Recap (traveler format) OR 9. Short Press +
#     Recap (traveler format)
#
# Notes
#   - Results have been tested on Firefox 3-33, IE 7-11, Safari 3.1–5.17,
#     and Chrome 4-38. Feedback on functionality under other browsers would
#     be appreciated. Very old browsers such as IE4 do not support CSS and
#     therefore will probably render the results poorly.
#
#   - This program produces "readable" HTML. The file size would be smaller
#     if all the white space were stripped. But the slightly larger file
#     size will usually not affect the page load time because most modern
#     browsers and web servers support transport compression (e.g. gzip).
#
#   - Feedback and bug reports should be sent to software@lajollabridge.com
#
# 1.3.5 - 19-Nov-2014 - Current version
# 1.0.1 - 25-Sep-2008 - Initial Release

use strict;
use threads;
use Config;
use URI::Escape;

my $VERSTR = '1.3.5';
(my $SCRIPTPATH = $0) =~ s/[^\\\/]*$//;
my $MAC_OS_X_PATH = $SCRIPTPATH . ($SCRIPTPATH eq '' ? '' : '/') . 'mac-os-x' . '/';

# Version of data mining JSON output.
my $DATAMINING_FORMAT_VERSION = 2;

# Amount to drop priority of ddd double dummy solver on Unix.
my $DDD_UNIX_NICE = 15;

# Default location of ACBL Report HTML help.
my $DEFAULT_HELP_URL = 'http://lajollabridge.com/Software/ACBLmerge/ACBLmergeReport.htm';

# Default location of ACBLscore game files.
my $DEFAULT_GAMEFILE_DIR = 'C:/ACBLSCOR/GAMEFILE/';

# Masterpoint database filename.
my $MPDB_FNAME = 'MP.dat';

# Use 7-Zip instead of Archive-LHA to read LZH compression.
my $USE_7ZIP_ON_WINDOWS = 1;
my $USE_7ZIP_ON_OSX     = 1;

# Exit codes
my $EXIT_SUCCESS              =   0;
my $EXIT_ARG_PARSING          =  -1;
my $EXIT_FILE_ERR             =  -2;
my $EXIT_NOT_A_PDF_FILE       =  -3;
my $EXIT_UNEXPECTED_FILE_EXT  =  -4;
my $EXIT_ACBLSCORE_PARSE_ERR  =  -5;
my $EXIT_PBN_PARSE_ERR        =  -6;
my $EXIT_DDD_NOT_ON_PATH      =  -7;
my $EXIT_DDD_PARSE_ERR        =  -8;
my $EXIT_NEED_PERL_PACKAGE    =  -9;
my $EXIT_NOT_GAMEFILE_EXT     = -10;
my $EXIT_BWS_PARSE_ERR        = -11;
my $EXIT_MAKE_APPDIR_FAIL     = -12; 
my $EXIT_NO_RESULT_FILE       = -13;
my $EXIT_DDSOLVER_NOT_ON_PATH = -14;
my $EXIT_DDSOLVER_EXEC_ERROR  = -15;
my $EXIT_REPROCESS_ERR        = -16;
my $EXIT_BRI_PARSE_ERR        = -17;
my $EXIT_MDB_READ_ERR         = -18;
my $EXIT_NOT_GAMEFILE         = -19;
my $EXIT_MULTIPLE_EVENTS      = -20;
my $EXIT_7ZIP_ERROR           = -21;
my $EXIT_NEED_32_BIT_PERL_ERR = -22;

if (scalar(@ARGV) == 0) {
  (my $bname = $0) =~ s/.*[\\\/]//;

  print <<"DONE";
  
  Missing parameter(s)

  Usage: $bname [-h handfname] [-r [resfname]] [-b [bwsfname]]
  [-o [outfname]] [-g [gibfname]] [-p [pbnfname]] [-l linfname] 
  [-pdf [pdffname]]  [-txt [txtfname]] [-dd] [-t title] [-iphone]
  [-pbnevt event_name] [-hurl URL] [-w] [-tm] [-c #] [-fs [gamefname]]
  [-mp [gamefname]] [-fc [gamefname]] [-v] [-q] [-crlf] [-giburl URL]
  [-pbnurl URL] [-linurl URL] [-txturl URL] [-mssurl URL] [-ih headfname]
  [-isb sbdyfname] [-ieb ebdyname] [-appdir dir] [-cgip URLbase]
  [-dm [dmfname]]

  handfname : Hand record filename (Duplimate, PBN, or GIB format)
  resfname  : ACBLscore results filename. Default extension is .txt
              Can also read HTML files generated by ACBLscore.
  bwsfname  : Bridgemate / BridgePad filename. Default extension is .bws
  outfname  : HTML output filename. If the -o option is not specified,
              output is sent to STDOUT. Default file extension is .htm
  gibfname  : Write hands in Goren in a Box (GIB) library format. If -dd is
              also specified, GIB file will contain the makeable contracts.
              Default file extension is .gib
  pbnfname  : Write hands in Portable Bridge Notation (PBN) format. Default
              file extension is .pbn
  linfname  : Write hands in Bridge Base (LIN) format. Default file
              extension is .lin
  pdffname  : Specifies filename or URL for PDF hyperlink in output HTML.
              Typically this target would be PDF file produced by Dealmaster
              Pro for printing paper copies of the hand records.
  txtfname  : Specifies filename for plaintext output (sometimes desired if
              original ACBLscore output was in HTML)
  gamefname : ACBLscore game filename. Required for field strength (-fs)
              option, as well as the masterpoint (-mp) and faces (-fc)
              tooltip display options.
  dmfname   : Specifies filename for data mining JSON.

  To do anything useful, either the -h or -r option must be specified along
  with a filename.
  
  If a filename is not supplied for any of the -r, -g, -p, -l, -pdf switches
  the filename is automatically generated by changing the file extension of the
  full filename of the hand record filename, i.e. .dup/.pbn/.gib/.bri -->
  .txt, .gib, .pbn, .lin, or .pdf respectively.

  If a filename is not supplied for any of the -b, -txt, -o, -iphone, -dm, -fs,
  or -mp switches, the filename is automatically generated by changing the
  file extension of the full filename of the ACBLscore results filename, i.e.
  .txt/.htm --> .bws, .txt, .htm, .htm, .json, .ACA/.ACE/.ACM/.ACL (last two)
  respectively.
  
  Options
    -dd     - Include double dummy makes, par contract, and LoTT statistics
    -t      - Specify title of HTML output. If not specified, the title
              defaults to "Mmm DD, YYYY Game Result" where the date is
              derived from the DATE> header of the ACBLscore file.
    -w      - Include list of masterpoint winners at top of output.
    -iphone - Create additional output HTML file for viewing on the iPhone.
    -pbnevt - Defines Event Name to be used in PBN output. If not specified
              PBN output uses the Event Name from the ACBLscore results file.
    -fs     - Include field strength calculation
    -mp     - Include player masterpoints (hovering tooltip over player names)
    -fc     - Show players faces (hovering toolip over player names)
    -tm     - Include table marker in the center of each hand.
    -as     - Use American Style contract notation, e.g. 2S 9, instead of 2S +1
    -c      - Specify number of CPUs (cores) to use for double dummy analysis.
    -q      - Quiet mode. Do not print any informative messages to STDERR.
    -v      - Print program version on STDERR (overrides -q)

  Advanced Options
    -ih     - Specify file of HTML code to insert in the <head> element of
              the output. Code is added after ACBLmerge <head> content.
    -isb    - Specify file of HTML code insert at the start of the <body>
              element; for example to include a menu bar or banner.
    -ieb    - Specify file of HTML code to insert at the end of the <body>
              element; for example to include contact information.
    -crlf   - Write Win32 style newlines (CR LF) even when running on Unix.
    -hurl   - Specify URL that explains features of ACBLmerge.pl output
              This is used to create a link at the top of the HTML output.
              Example: -hurl "/software/ACBLmergeReport.htm". Defaults to
              $DEFAULT_HELP_URL
              if -hurl is not specified.
    -nohurl - Do not include a help link, not even the default.
    -giburl - Specify URL to GIB file (only required if GIB file will not be
              placed in same directory as HTML output file on the web server)
    -pbnurl - Specify URL to PBN file (only required if PBN file will not be
              placed in same directory as HTML output file on the web server)
    -linurl   Specify URL to LIN file (only required if LIN file will not be
              placed in same directory as HTML output file on the web server)
    -txturl - Specify URL to text file (only required if PBN file will not be
              placed in same directory as HTML output file on the web server)
    -mssurl - Specify URL to multiple session / section overall rankings
    -appdir - Explicitly set application directory
    -cgip   - Specify root of hyperlink for player names in results section


  Note: for clarity the -ih, -isb, -ieb options have the alternate long
  forms of -ihead, -isbody, and -iebody.   

  Produces HTML output that merges bridge hands with ACBLscore text results,
  and optionally the contract and/or opening lead information from the
  Bridgemate or BridgePad electronic scoring systems. Hands may be supplied
  in Duplimate format (.dup/.bri), PBN, or GIB (Goren in a Box) library format.
  The GIB format can store double dummy results. The ACBLscore results need
  to be saved in the "traveler format". From ACBLscore navigate Report (menu)
  --> Recap/Press (menu) --> Screen/File (LR) --> 8. Press + Recap
  (traveler format). Or alternatively 9. Short Press + Recap (traveler format).
  The report may be saved in either text or HTML format.

  The HTML output includes advanced clipboard copy features and the HCP count
  for each board. For each board, the pairs are sorted by N-S matchpoints.
  If double dummy analysis is performed, makeable contracts (+number of tricks
  for every contract), the par contract, and a LoTT calculation will also be
  shown. Hands may also be output in Portable Bridge Notation (PBN) format
  for trick by trick double dummy analysis in programs such as Bridgify and
  the Bridge Captain Double Dummy Solver (both free).

  Example: perl ACBLmerge.pl -h 080914A.dup -r -dd -o -p -w

  The input files are 080914A.dup and 080914A.txt (the ACBLscore filename
  080914A.txt is implicitly assumed here because it is required but was not
  supplied). Likewise, the HTML output will default to 080914A.htm since the
  -o switch has no argument. The -dd switch specifies that double dummy
  analysis will be performed. The PBN output will default to 080914A.pbn.
  No GIB output will be generated since the -g is missing.

  Online documentation is located at:
  http://www.lajollabridge.com/Software/ACBLmerge/ACBLmergeAbout.htm
  
DONE
     
  exit($EXIT_SUCCESS);
}

# Tell Mac OS X specific binary where to find the libraries they depend on.
$ENV{'DYLD_LIBRARY_PATH'} = $MAC_OS_X_PATH if $^O eq 'darwin';

# Parse command line arguments.
my %opt;
while ( my $arg = shift(@ARGV) ) {
  if ( substr($arg,0,1) ne '-' ) {
    # push @fnames, $arg;
    print STDERR "Unexpected string: $arg (ignored)\n";
    next;
  };
  my $sw = substr($arg,1);
  if ($sw eq 'h') {
    $arg = shift(@ARGV);
    if (!defined $arg) {
      print STDERR "\n  -h switch is missing argument.\n"; exit($EXIT_ARG_PARSING);
    }
    if (!-f $arg) {
      print STDERR "\n  File for -$sw switch does not exist: $arg\n";
      exit($EXIT_FILE_ERR);
    }
    $opt{'handfname'} = $arg;
  }
  elsif ($sw eq 'r') {
    $arg = shift(@ARGV);
    if (defined $arg && $arg !~ /^-/) {
      if (!-f $arg) {
        print STDERR "\n  File for -$sw switch does not exist: $arg\n";
        exit($EXIT_FILE_ERR);
      }
      $opt{'resfname'} = $arg;
    }
    else {
      unshift @ARGV, $arg;
      # Placeholder because -h argument may not be parsed yet.
      $opt{'resfname'} = '*derived*';
    }
  }
  elsif ($sw eq 'b') {
    $opt{'bws'} = 1;
    $arg = shift(@ARGV);
    if (defined $arg && $arg !~ /^-/) {
      if (!-f $arg) {
        print STDERR "\n  File for -$sw switch does not exist: $arg\n";
        exit($EXIT_FILE_ERR);
      }
      $opt{'bwsfname'} = $arg;
    }
    else {
      unshift @ARGV, $arg;
      # Placeholder because -r argument may not be parsed yet.
      $opt{'bwsfname'} = '*derived*';
    }
  }
  elsif ($sw eq 'o') {
    $arg = shift(@ARGV);
    if (defined $arg && $arg !~ /^-/) {
      $opt{'outfname'} = $arg;
    }
    else {
      unshift @ARGV, $arg;
      $opt{'outfname'} = '*derived*';
    }
  }
  elsif ($sw eq 'g') {
    $arg = shift(@ARGV);
    if (defined $arg && $arg !~ /^-/) {
      $opt{'gibfname'} = $arg;
    }
    else {
      unshift @ARGV, $arg;
      $opt{'gibfname'} = '*derived*';
    }
  }
  elsif ($sw eq 'p') {
    $arg = shift(@ARGV);
    if (defined $arg && $arg !~ /^-/) {
      $opt{'pbnfname'} = $arg;
    }
    else {
      unshift @ARGV, $arg;
      $opt{'pbnfname'} = '*derived*';
    }
  }
  elsif ($sw eq 'l') {
    $arg = shift(@ARGV);
    if (defined $arg && $arg !~ /^-/) {
      $opt{'linfname'} = $arg;
    }
    else {
      unshift @ARGV, $arg;
      $opt{'linfname'} = '*derived*';
    }
  }
  elsif ($sw eq 'pdf') {
    $arg = shift(@ARGV);
    if (defined $arg && $arg !~ /^-/) {
      my $isWindowsPath = $arg =~ /^([A-Za-z]:|\\\\)/;
      if ($isWindowsPath && !-f $arg) {
        print STDERR "\nWarning: file for -$sw switch does not exist: $arg\n";
        print STDERR "Place PDF file in same directory as HTML file on web server.\n\n";
      }
      $opt{'pdffname'} = $arg;
    }
    else {
      unshift @ARGV, $arg;
      $opt{'pdffname'} = '*derived*';
    }
  }
  elsif ($sw eq 'txt') {
    $arg = shift(@ARGV);
    if (defined $arg && $arg !~ /^-/) {
      $opt{'txtfname'} = $arg;
    }
    else {
      unshift @ARGV, $arg;
      $opt{'txtfname'} = '*derived*';
    }
  }
  elsif ($sw eq 'dm') {
    $arg = shift(@ARGV);
    if (defined $arg && $arg !~ /^-/) {
      $opt{'dmfname'} = $arg;
    }
    else {
      unshift @ARGV, $arg;
      $opt{'dmfname'} = '*derived*';
    }
  }
  elsif ($sw eq 'fs') {
    $opt{'fieldstrength'} = 1;
    $arg = shift(@ARGV);
    if (defined $arg && $arg !~ /^-/) {
      $opt{'gamefname'} = $arg;
    }
    else { unshift @ARGV, $arg; }    
  }
  elsif ($sw eq 'mp') {
    $opt{'mpdisplay'} = 1;
    $arg = shift(@ARGV);
    if (defined $arg && $arg !~ /^-/) {
      $opt{'gamefname'} = $arg;
    }
    else { unshift @ARGV, $arg; }    
  }
  elsif ($sw eq 'fc') {
    $opt{'showfaces'} = 1;
    $arg = shift(@ARGV);
    if (defined $arg && $arg !~ /^-/) {
      $opt{'gamefname'} = $arg;
    }
    else { unshift @ARGV, $arg; }
  }
  elsif ($sw eq 't') {
    $arg = shift(@ARGV);
    if (!defined $arg || $arg =~ /^-/) {
      print STDERR "\n  -t switch is missing argument.\n"; exit($EXIT_ARG_PARSING);
    }
    $opt{'title'} = $arg;
  }
  elsif ($sw eq 'iphone') { $opt{'iphone'} = 1; }
  elsif ($sw eq 'pbnevt') {
    $arg = shift(@ARGV);
    if (!defined $arg || $arg =~ /^-/) {
      print STDERR "\n  -pbnevt switch is missing argument.\n"; exit($EXIT_ARG_PARSING);
    }
    $opt{'pbnevt'} = $arg;
  }
  elsif ($sw eq 'hurl') {
    $arg = shift(@ARGV);
    if (!defined $arg || $arg =~ /^-/) {
      print STDERR "\n  -hurl switch is missing argument.\n"; exit($EXIT_ARG_PARSING);
    }
    $opt{'hurl'} = $arg;
  }
  elsif ($sw eq 'nohurl') {
    $opt{'nohurl'} = $arg;
  }
  elsif ($sw eq 'giburl' || $sw eq 'pbnurl' || $sw eq 'linurl' || $sw eq 'txturl') {
    $arg = shift(@ARGV);
    if (!defined $arg || $arg =~ /^-/) {
      print STDERR "\n  -$sw switch is missing argument.\n"; exit($EXIT_ARG_PARSING);
    }
    $opt{$sw} = $arg;
  }
  elsif ($sw eq 'c') {
    $arg = shift(@ARGV);
    if (!defined $arg || $arg =~ /^-/) {
      print STDERR "\n  -c switch is missing argument.\n"; exit($EXIT_ARG_PARSING);
    }
    if ($arg !~ /^\d+$/) {
      print STDERR "\n  -c takes an integer argument.\n"; exit($EXIT_ARG_PARSING);
    }
    if ($arg == 0) {
      print STDERR "\n -c 0 will not get anything done!\n"; exit($EXIT_ARG_PARSING);
    }
    $opt{'ncpu'} = $arg;
  }
  elsif ($sw eq 'dd') { $opt{'dd'} = 1; }
  elsif ($sw eq 'tm') { $opt{'tablemarker'} = 1; }
  elsif ($sw eq 'as') { $opt{'americanstyle'} = 1; }
  elsif ($sw eq 'q')  { $opt{'quiet'} = 1; }
  elsif ($sw eq 'v')  { $opt{'showver'} = 1; }
  elsif ($sw eq 'w')  { $opt{'listwinners'} = 1; }
  elsif ($sw eq 'crlf') { $opt{'crlf'} = 1; }
  elsif ($sw eq 'ih' || $sw eq 'isb' || $sw eq 'ieb') {
    $arg = shift(@ARGV);
    if (!defined $arg || $arg =~ /^-/) {
      print STDERR "\n  -$sw switch is missing filename argument.\n";
      exit($EXIT_ARG_PARSING);
    }
    elsif (!-f $arg) {
      print STDERR "\n  File for -$sw switch does not exist: $arg\n";
      exit($EXIT_FILE_ERR);
    }
    $opt{"${sw}_fname"} = $arg;
  }
  elsif ($sw eq 'appdir') {
    $arg = shift(@ARGV);
    if (!defined $arg || $arg =~ /^-/) {
      print STDERR "\n  -appdir switch is missing argument.\n"; exit($EXIT_ARG_PARSING);
    }
    $opt{'appdir'} = $arg;
  }
  elsif ($sw eq 'cgip') {
    $arg = shift(@ARGV);
    if (!defined $arg || $arg =~ /^-/) {
      print STDERR "\n  -cgip switch is missing argument.\n"; exit($EXIT_ARG_PARSING);
    }
    $opt{'cgip'} = $arg;
  }
  elsif ($sw eq 'mssurl') {
    $arg = shift(@ARGV);
    if (!defined $arg || $arg =~ /^-/) {
      print STDERR "\n  -mssurl switch is missing argument.\n"; exit($EXIT_ARG_PARSING);
    }
    $opt{'mssurl'} = $arg;
  }
  else {
    print STDERR "Unrecognized switch: $arg\n";
  }
}

my $errmsg;
if ( $opt{'showver'} ) {
  print STDERR "ACBLmerge $VERSTR\n";
}
if ($opt{'hurl'} && $opt{'nohurl'} && ! $opt{'quiet'}) {
  print STDERR "Warning: both -hurl and -nohurl switches used. No help URL will be included.\n";
}
if ( $opt{'bws'} && $^O eq 'MSWin32' && $Config{'ptrsize'} == 8 ) {
  print STDERR <<'DONE';
  
You are using a 64-bit version of Perl. But on Windows, the -b option requires
the 32-bit Perl interpreter in order to access the 32-bit only Microsoft
libraries that can read Bridgemate, BridgePad, and BridgeScorer files.
DONE
  exit($EXIT_NEED_32_BIT_PERL_ERR);
}

if (! defined $opt{'ncpu'}) {
  $opt{'ncpu'} = ($^O eq 'MSWin32') ? $ENV{'NUMBER_OF_PROCESSORS'} : 1;
  # Guard against people who change environment variables that shouldn't be changed.
  $opt{'ncpu'} = 1 if ! defined $opt{'ncpu'} || $opt{'ncpu'} !~ /^\d+$/;
}

my ($hformat, $hbname);
if ( $opt{'handfname'} ) {
  if ( $opt{'handfname'} =~ /\.(dup|bri)$/i ) { $hformat = 'Duplimate'; }
  elsif ( $opt{'handfname'} =~ /\.pbn$/i ) { $hformat = 'PBN'; }
  elsif ( $opt{'handfname'} =~ /\.gib$/i ) { $hformat = 'GIB'; }
  else {
    print STDERR "\n  Hand filename does not end with .dup, .pbn, .gib, or .bri extension: ",
    $opt{'handfname'}, "\n";
    exit($EXIT_UNEXPECTED_FILE_EXT);
  }
  
  # Strip file extension from filenames of hand records and and ACBLscore
  # results so they can be used to derive other filenames. 
  ($hbname = $opt{'handfname'}) =~ s/\.[A-Za-z0-9]+$//;
}

if ( $opt{'pdffname'} && $opt{'pdffname'} =~ /^([A-Za-z]:|\\\\)/ && -f $opt{'pdffname'} ) {
  # Check if PDF file really is a PDF file when PDF file has a Windows style path.
  if (!open(FH, $opt{'pdffname'})) {
    print STDERR "\n  Unable to open/read: $opt{'pdffname'}\n"; exit($EXIT_FILE_ERR);
  }
  read(FH, my $fheader, 4);
  close(FH);
  if ($fheader ne "%PDF") {
    printf STDERR "\n  PDF file does not appear to be a PDF (it does not start with " .
      "%PDF): $opt{'pdffname'}\n";
    exit($EXIT_NOT_A_PDF_FILE);
  }
}

# Generate derived filenames.
if ( !$opt{'resfname'} || $opt{'resfname'} eq '*derived*' ) {
  if (defined $hbname) {   $opt{'resfname'} = $hbname . '.txt'; }
  else {
    print STDERR <<'DONE';
An ACBLscore result file was not specified (via the -r option), nor can its
name automatically be generated from the hand record filename because that
was not specified either (via the -h option).
DONE
    exit($EXIT_NO_RESULT_FILE);
  }
}
(my $rbname = $opt{'resfname'}) =~ s/\.[A-Za-z0-9]+$//;
# See if we have a pair or team results file. Need to know this now because
# it affects the command line argument parsing.
my $gametype = gametype($opt{'resfname'});

if ( ($gametype eq 'pairs' || $gametype eq 'BAM') && ! $opt{'handfname'} && !$opt{'quiet'}) {
  my $evname = $gametype eq 'pairs' ? 'pair' : 'BAM';
  print STDERR <<"DONE";
  
For a $evname event, you probably want to supply a hand record (DUP, PBN, or GIB).
Otherwise much of the functionality of ACBLmerge is lost, though the field
strength, masterpoint tooltip, and face view options can still be used.

DONE
}

if ( !$opt{'bwsfname'} || $opt{'bwsfname'} eq '*derived*' ) {
  $opt{'bwsfname'} = $rbname . '.bws';
}
if ( defined $opt{'dmfname'} && $opt{'dmfname'} eq '*derived*' ) {
  $opt{'dmfname'} = $rbname . '.json';
}

my $htname = $rbname;
if ( defined $opt{'outfname'} ) {
  if ( $opt{'outfname'} eq '*derived*' ) { $opt{'outfname'} = $rbname . '.htm'; }
  else { ($htname = $opt{'outfname'}) =~ s/\.[A-Za-z0-9]+$//; }
}
if ( $opt{'iphone'} ) {
  $opt{'iphfname'} = $htname . '_iPhone.htm';
  if ($gametype ne 'pairs') {
    print STDERR <<'DONE'
iPhone customized output is only generated for pair events. The -iPhone switch
will be ignored.
DONE
  } 
}
if ( defined $opt{'gibfname'} && $opt{'gibfname'} eq '*derived*' ) {
  $opt{'gibfname'} = $hbname . '.gib';
}
if ( defined $opt{'pbnfname'} && $opt{'pbnfname'} eq '*derived*' ) {
  $opt{'pbnfname'} = $hbname . '.pbn';
}
if ( defined $opt{'linfname'} && $opt{'linfname'} eq '*derived*' ) {
  $opt{'linfname'} = $hbname . '.lin';
}
if ( defined $opt{'pdffname'} && $opt{'pdffname'} eq '*derived*' ) {
  $opt{'pdffname'} = $hbname . '.pdf';
}
if ( defined $opt{'txtfname'} && $opt{'txtfname'} eq '*derived*' ) {
  $opt{'txtfname'} = $rbname . '.txt';
}

# Read in hands. Since Perl treats function argument as an array, one
# has to return a reference to an array to return an array as an argument.
# PHD is a reference (pointer) to the hand (HD) array.
my $phd;
if ( defined $hformat ) {
  if ( $hformat eq 'Duplimate' ) {
    $phd = readDUP($opt{'handfname'});
  }
  elsif ( $hformat eq 'PBN' ) {
    $phd = readPBN($opt{'handfname'});
  }
  elsif ( $hformat eq 'GIB' ) {
    $phd = readGIB($opt{'handfname'});
  }
  else {
    die "Unsupported hand format: $hformat. Check code.";
  }
}

# Parse ACBLscore text or HTML output.
# For pair games $SECTIONS has text lines of each section; $EVT has parsed event
# information. $PPY has parsed player names and numbers. $BR has text lines for the
# results on each board. $BDATA has parsed board results.
# For team games, $PYTEAMS is a hashref that stores the player names, keyed by teams
# number, where the values are arrayrefs of player names.
my ($sections, $evt, $ppy, $br, $pbdata);
my ($pyteams, $pl);
my $pnn;
if ($gametype eq 'pairs' || $gametype eq 'BAM') {  
  (my $ec, $sections, $evt, $ppy, $br, $pbdata, $pnn) = 
    readACBLscorePairs($opt{'resfname'}, $gametype);
  exit($ec) if ($ec);
}
elsif ($gametype eq 'teams') {
  ($errmsg, $evt, $pyteams, $pl, $pnn) = readACBLscoreTeams($opt{'resfname'});
  if ($errmsg) { print STDERR "\n$errmsg\n"; exit($EXIT_ACBLSCORE_PARSE_ERR); }
}
else {
  die "Unsupported game type (expected 'pairs', 'teams', or 'BAM'). Check code.";
}

# If ACBLscore report included player numbers then we do not have to read the
# ACBLscore game file if an option was specified that requires player numbers. 
my $needGameFile = !defined $pnn &&
  ($opt{'fieldstrength'} || $opt{'mpdisplay'} || $opt{'showfaces'});
if ($needGameFile && !defined $opt{'gamefname'} ) {
  # ACBLscore game files have a strange naming convention. The file
  # extension changes depending on the time of the day (.ACM = morning,
  # .ACA = afternoon, .ACE = evening, and .ACL = late). The .ACB game
  # files are used for team games.
  my $lastchar = substr($rbname,-1,1);
  if ($lastchar !~ /M|A|E|L|B/i) {
    print STDERR <<"DONE";
Unable to generate automatic ACBLscore game file name for -fs and/or -mp
option because report file name excluding its extension ($rbname) does not
end in M, A, E, or L (ACBLscore game files end in .ACM, .ACA, .ACE, or .ACL).
DONE
    exit($EXIT_NOT_GAMEFILE_EXT);
  }
  $lastchar =~ tr/a-z/A-Z/;
  $opt{'gamefname'} = substr($rbname,0,-1) . '.AC' . $lastchar;
  if (!-f $opt{'gamefname'} && $^O eq 'MSWin32') {
    # Try default location of ACBLscore game files if game file is not found.
    (my $fname = $opt{'gamefname'}) =~ s/.*[\\\/]//;
    $fname = $DEFAULT_GAMEFILE_DIR . $fname;
    $opt{'gamefname'} = $fname if -f $fname;
  }
}

# Parse Bridgemate / BridgePad / BridgeScorer input file.
my ($bws, $brn, $bsc);
my $bwsHasConts = 0; my $bwsHasLeads = 0;
if ($opt{'bws'}) {
  ($errmsg, $bws, $brn, $bsc, $bwsHasConts, $bwsHasLeads) = readBWS($opt{'bwsfname'});

  if ($errmsg) {
    print STDERR "Failed to read Bridgemate / BridgePad / BridgeScorer file:\n$errmsg\n";
    exit($EXIT_BWS_PARSE_ERR);
  }
  if (!$opt{'quiet'}) {
    print STDERR 'Electronic scoring file contains sections: ', 
      join(' ', sort(keys %$bsc)), "\n"; 
  }
  
  # Check if BWS file contains data for all the sections in the ACBLscore report.
  # ACBLscore section can be single letter, e.g. 'A' or a doubled letter, e.g. 'EE'.
  # Bridgemate records single letter sections with a trailing space, e.g. 'A '. Look
  # for section with and without a trailing space in case BridgePad is different or
  # the electronic scoring software cleans up this issue later.
  foreach my $section (sort keys %$sections) {
    if (!exists $bsc->{$section} && !exists $bsc->{$section . ' '} 
      && !exists $bsc->{$section . '  '} && !$opt{'quiet'}) {
      print STDERR "Warning: section $section information not found in the BWS file.\n";     
    }
  }
  
  # Check if the opening leads are from the correct hand. The Bridgemates devices
  # do not make this check at the time of data entry.
  $bws = leadCheck($sections, $phd, $bsc, $bws) if $bwsHasLeads;  
}

if ( $needGameFile ) {
  ($errmsg, $pnn) = playerNumsAndNames( $opt{'gamefname'} );
  if ($errmsg) { print STDERR "$errmsg\n"; exit($EXIT_FILE_ERR); }
}

my ($pmp, $fsdata, $db_year, $db_mmm, $teamMP);
if ( $opt{'fieldstrength'} || $opt{'mpdisplay'} ) {
  checkMPdb(appDir() . $MPDB_FNAME);

  # Computing MP means from all the players extracted from the ACBL game file
  # can be wrong because a game file can contain multiple events. Must restrict
  # to players in the event we are processing.
  my @pnums; my $nPlayers = 0; my $nLookupFail = 0;
  if ($gametype eq 'pairs') {
    foreach my $pairid (keys %$ppy) {
      foreach my $label ('player1', 'player2') {
        $nPlayers++;
        my $playerName = $ppy->{$pairid}{$label};
        my $pnum = $pnn->{$playerName};
        if ($pnum) { push @pnums, $pnum } else { $nLookupFail++; } 
      }
    }
  }
  elsif ($gametype eq 'teams') {
    foreach my $teamnum (keys %$pyteams) {
      my $playerNames = $pyteams->{$teamnum};
      $nPlayers += $#$playerNames + 1;
      foreach my $playerName (@$playerNames) {
        my $pnum = $pnn->{$playerName};
        if ($pnum) { push @pnums, $pnum } else { $nLookupFail++; }
      }
    }
  }
  elsif ($gametype eq 'BAM') {
    foreach my $pairid (keys %$ppy) {
      my $playerNames = $ppy->{$pairid}{'players'};
      $nPlayers += $#$playerNames + 1;
      foreach my $playerName (@$playerNames) {
        my $pnum = $pnn->{$playerName};
        if ($pnum) { push @pnums, $pnum } else { $nLookupFail++; }
      }
    }
  }
  else {
    die "Unsupported game type (expected 'pairs', 'teams', or 'BAM'). Check code.";    
  }
  
  if ($nLookupFail / $nPlayers > 0.2 && !$opt{'quiet'}) {
    print STDERR <<"DONE";
Warning: More than 20% ($nLookupFail) player names in the text (or HTML) report file were
not found in the ACBLscore game file. Maybe the wrong game file was supplied.
The program does not find non-ACBL members in the game file so that may also 
account for the lookup failures.

DONE
  }
  ($errmsg, $pmp, my $mpfail, $db_year, my $db_mon) =
    lookupMP(\@pnums, appDir() . $MPDB_FNAME);
  if ($errmsg) { print STDERR $errmsg; exit(); }
  # Catch case where database was not examined because there were no player numbers to lookup.
  $db_mmm = defined $db_mon ? monthMMM($db_mon) : '';
  
  if ( $opt{'fieldstrength'} ) {
    my ($ndata, $mean, $geomean) = mpmeans([values %$pmp]);
    $fsdata = {mean => $mean, geomean => $geomean, ndata => $ndata, 
      nNonMember => $nLookupFail, nFail => scalar(@$mpfail)};
  }
  
  if ($gametype eq 'teams' && $opt{'mpdisplay'}) {
    # Calculate masterpoint mean and geomean and (seed) rank for each team.
    $teamMP = teamMPmeans($gametype, $pyteams, $pnn, $pmp);
  }
  elsif ($gametype eq 'BAM' && $opt{'mpdisplay'}) {
    # Calculate masterpoint mean and geomean and (seed) rank for each BAM team.
    $teamMP = teamMPmeans($gametype, $ppy, $pnn, $pmp);
  }
}

if ($opt{'dd'} && defined $opt{'handfname'}) {
  # If hands were read from a GIB or PBN file, the double dummy results may
  # already be present for all hands.
  my $haveAllDD = 1; my $suspectDD = 1;
  my $nhands = scalar(keys %$phd);
  for my $hnum (sort {$a <=> $b} keys %$phd) {
    my $dd = $$phd{$hnum}{'dd'};
    if ( $haveAllDD && (!$dd || $dd =~ /-/) ) { $haveAllDD = 0; }
    if ( $suspectDD && defined $dd) {
      for (my $i = 0; $i < 20; $i += 2) {
        # 2-6 E-W is 7-11 tricks N-S ($dd values are tricks N-S can take)
        if ( substr($dd,$i,1) =~ /7|8|9|A|B/ ) { $suspectDD = 0; last; }
        if ( substr($dd,$i+1,1) =~ /[2-6]/ ) { $suspectDD = 0; last; }
      }    
    }
  }
  if (!$haveAllDD || $suspectDD) {
    if (! $opt{'quiet'} ) {
      if ($haveAllDD && $suspectDD) {
        print STDERR <<"DONE";
Double dummy results were found for all hands but they appear to be inaccurate.
because no contract played by any seat on any hand makes 2-6 tricks. This may
be the because the file was produced by Dealmaster Pro which does not always
compute double dummy results for all contracts from all seats.
 
DONE

      }
      printf STDERR "Performing double dummy analysis for %d boards. " .
      "(may take a minute or so)\n", scalar(keys %$phd);
    }
    if ($^O eq 'MSWin32' || $^O eq 'darwin') {
      $phd = invokeDDsolver($phd);
    }
    else {
      ($phd, my $etime) = invokeDD($phd);
      if (! $opt{'quiet'} ) {
        printf STDERR "Double dummy analysis completed in %d min %d sec " .
        "(%0.1f sec/board ave)\n", ($etime/60), ($etime % 60), ($etime/$nhands);
      }
    }
  }
}

my $renameOriginal;
my $outfname = $opt{'outfname'};
if ($outfname) {
  (my $outfname_lower  = $opt{'outfname'}) =~ tr/A-Z/a-z/;
  (my $resfname_lower  = $opt{'resfname'}) =~ tr/A-Z/a-z/;
  $renameOriginal = ($resfname_lower eq $outfname_lower);
  
  if ($renameOriginal) { $outfname .= "_tmp"; }
  if (! $opt{'quiet'} ) { print STDERR "Creating HTML file: $opt{'outfname'}\n"; }
}
if ($gametype eq 'pairs' || $gametype eq 'BAM') {
  if ( $opt{'dd'} ) {
    # Compute LoTT and par information once.
    foreach my $bnum (sort {$a <=> $b} keys %$phd) {
      my ($dealer, $vul) = dealerVul($bnum);
      ($phd->{$bnum}{'totalTricks'}, $phd->{$bnum}{'totalTrumps'}) = LoTTstats($phd->{$bnum});
      ($phd->{$bnum}{'parNS'}, $phd->{$bnum}{'parEW'}, $phd->{$bnum}{'parHTML'},
       $phd->{$bnum}{'parContracts'}) = par($phd->{$bnum}, $vul);
    }
  }
  dumpHTMLpairs('default', $gametype, $evt, $sections, $br, $phd, $ppy, $pbdata, $outfname,
    $pnn, $pmp, $fsdata, $db_year, $db_mmm, $bsc, $bws, $bwsHasConts, $bwsHasLeads, $teamMP);
  if ($opt{'iphone'} && $gametype ne 'BAM') {
    if (! $opt{'quiet'} ) { print STDERR "Creating HTML file: $opt{'iphfname'}\n"; }
    dumpHTMLpairs('iPhone', $gametype, $evt, $sections, $br, $phd, $ppy, $pbdata, $opt{'iphfname'}, 
      $pnn, $pmp, $fsdata, $db_year, $db_mmm, $bsc, $bws, $bwsHasConts, $bwsHasLeads, $teamMP);
  }
}
elsif ($gametype eq 'teams') {
  dumpHTMLteams($opt{'resfname'}, $outfname, $evt, $pnn, $pmp, 
    $fsdata, $db_year, $db_mmm, $pyteams, $teamMP);
}
else {
  print STDERR "Unsupported game type: $gametype (check code).\n";
}

if ($renameOriginal) {
  (my $outfnameOrig = $opt{'outfname'}) =~ s/\.htm$/\.orig\.htm/i;
  rename $opt{'outfname'}, $outfnameOrig;
  rename $outfname, $opt{'outfname'};
  if (! $opt{'quiet'}) {
    print STDERR "Renamed orignal ACBLscore HTML report to: $outfnameOrig\n";
  }
}
if ($opt{'dmfname'}) {
  if (! $opt{'quiet'} ) { print STDERR "Creating JSON file: $opt{'dmfname'}\n"; }
  dmJSONpairs($opt{'dmfname'}, $evt, $sections, $phd, $ppy, $pnn, $fsdata, $pbdata,
    $bsc, $bws, $bwsHasConts, $bwsHasLeads) if $gametype eq 'pairs' || $gametype eq 'BAM';
  dmJSONteams($opt{'dmfname'}, $evt, $pyteams, $pl, $pnn, $fsdata) if $gametype eq 'teams';
}
if ($opt{'txtfname'}) {
  if (! $opt{'quiet'} ) { print STDERR "Creating Plaintext file: $opt{'txtfname'}\n"; }
  writePlaintext($sections, $br, $opt{'txtfname'}); }
if ($opt{'gibfname'}) {
  if (! $opt{'quiet'} ) { print STDERR "Creating GIB file: $opt{'gibfname'}\n"; }
  writeGIB($opt{'gibfname'}, $phd); }
if ($opt{'pbnfname'}) {
  if (! $opt{'quiet'} ) { print STDERR "Creating PBN file: $opt{'pbnfname'}\n"; }
  writePBN($opt{'pbnfname'}, $phd, $evt);
}
if ($opt{'linfname'}) {
  if (! $opt{'quiet'} ) { print STDERR "Creating LIN file: $opt{'linfname'}\n"; }
  writeLIN($opt{'linfname'}, $phd, $evt);
}

exit($EXIT_SUCCESS);


sub gametype {
  # Determines ACBLscore game type. Normally this is 'pairs' or 'teams'
  # However, 'BAM' (board-a-match) and 'VP' (teams with all combinations
  # of four pairs) are special cased because they don't fit into the normal
  # pairs or teams model. This is an early check. readACBLscorePairs(),
  # readACBLscoreTeams(), and similar do the serious work of fully parsing
  # a result file.
  #
  # Also returns all event names encountered (to check for attempts to process
  # multiple events at once, a case which is not currently handled).
  my ($fname) = @_;
  if (! open(FILE, '<:crlf', $fname)) {
    print STDERR "Unable to open/read: $fname\n";
    exit($EXIT_ACBLSCORE_PARSE_ERR);
  }
  my ($fline, $type, @eventNames);
  my $prevEventName = '';
  while ($fline = <FILE>) {
    if ($fline =~ /^PAIRS>? / && !defined $type) { $type = 'pairs'; }
    if ($fline =~ /^TEAMS>? / && !defined $type) { $type = 'teams'; }
    if ($fline =~ /^EVENT>/) {
      my ($eventName) = $fline =~ /^EVENT>([^|]+)/; $eventName =~ s/\s+$//;
      # It's not clear how to check for Board-a-Match events. Hope that event name
      # always includes BAM (all uppercase) or B-A-M or Board-A-Match regardless
      # of case at a word boundary.
      $type = 'BAM' if !defined $type && 
        ($fline =~ /\bBAM\b/ || $fline =~ /\bB-A-M\b/i || $fline =~ /\bBoard-A-Match\b/i);
      if ($eventName ne $prevEventName) {
        push @eventNames, $eventName;  $prevEventName = $eventName;
      }
    }
  }
  close(FILE);
  if ($#eventNames > 0) {
    print STDERR <<"DONE";

The ACBLscore results file contains multiple events as listed below. Only
one event can be processed at a time (though in most cases multiple combined
sections from a single event can be processed together). Export each event
separately from ACBLscore and process it separately.

DONE
    print join("\n", @eventNames), "\n";
    exit($EXIT_MULTIPLE_EVENTS);
  } 
  
  return $type if $type;
  
  print STDERR <<"DONE";
  
The results file does not appear to be an ACBLscore results file because none
of the following lines was found in it:

  PAIRS IN STRAT ...
  PAIRS>
  TEAMS IN STRAT ...
  TEAMS>
  
DONE
  exit($EXIT_ACBLSCORE_PARSE_ERR);    
}

sub readACBLscorePairs {
  # Reads ACBLscore traveler report for pair or BAM events.
  #
  # Supports either text or HTML format. For the HTML versions of its reports,
  # ACBLscore basically just slaps a <pre> tag around text version. It fails
  # to declare a <DOCTYPE>, include a <body> tag (not to mention a <title>),
  # or otherwise get the basics of HTML correct. Sigh!
  #
  # Board-a-Match (BAM) Teams is a rare event format which programmatically
  # is easiest to treat as a modified pairs format. For BAM, the index to %PY
  # is a team id instead of a pair id.
  
  my ($fname, $gametype) = @_;
  # %SECTIONS holds text for each section (e.g. A N-S) from EVENT> line to
  # Totals line. $EVT holds parsed information about the event (taken from
  # the first section encountered). %PY holds pair numbers (e.g. AN12) and
  # player names. %BR holds text lines for each board result. %BDATA holds
  # each results on each board.
  my (%sections, %py, %br, %bdata);
  my ($pnum, %pnn);
  my %evt = ('gametype', $gametype, 'finalAwards', 1, 'hasPct', 0,
    'hasOverallRanks', 0, 'isMultiSession', 0);
  my ($have_evt_info, %colpos);
  my ($last_pair_id, @pynames);

  open(FILE, '<:crlf', $fname) or return("  Unable to open/read: $fname");

  while (my $fline = <FILE>) {
    # ACBLscore writes pseudotags like <!A> at the start of each section,
    # another violation of the HTML standard.
    if ($fline =~ /^\s*$/ ||  $fline =~ /^<![A-Z]+\d*>/ ||
        $fline =~ /^<html>\s*<pre>$/ || $fline =~ /^<\/pre>\s*<\/html>$/) { next; }
    
    if ($fline =~ /\s*RESULTS OF BOARD/ ) {
      my ($hnum) = ($fline =~ /\s*RESULTS OF BOARD\s+(\d+)/);
      # Skip empty line and "SCORES  MATCHPOINTS   NAMES", and
      # "N-S   E-W    N-S    E-W" lines.
      $fline = <FILE>; $fline = <FILE>; $fline = <FILE>;
      my (@textlines, @results);
      while (1) {
        $fline = <FILE>;
        if (!$fline || $fline =~ /^-/) { $br{$hnum} = \@textlines; last; }
        chomp($fline);
        push @textlines, $fline;
        
        # Populate %BDATA. This code does not handle split score adjustments
        # perfectly because it only records NS masterpoints with the assumption
        # that EW masterpoints can be derived as needed, an assumption that breaks
        # down with a split ruling. This is a practical limitation designed to
        # reduce size of the output HTML.
        my $scoreline = substr($fline, 1, 10);
        (my $mp_ns = substr($fline, 12, 7)) =~ s/\s+//;
        (my $mp_ew = substr($fline, 19, 7)) =~ s/\s+//;
        my($pair_id_ns, $pair_id_ew) = substr($fline, 27, 48) =~ /^([^-]+).*vs ([^-]+)/;
        
        my ($ns_score, $ew_score);
        # Scoreline has some special cases such as PASS and the AVE- and AVE+
        # adjusted scores.
        if ($scoreline =~ /PASS/) { $ns_score = 'PASS'; }
        else {
          # It looks like we are grabbing one character too many but we are not because
          # the plus and minus symbols in AVE+ and AVE- extend one column beyond the
          # ordinary right aligned scores.
          ($ns_score = substr($fline, 1, 5)) =~ s/\s+//g;
          ($ew_score = substr($fline, 7, 5)) =~ s/\s+//g;
          # print "$ns_score | $ew_score\n";
          if ($ns_score && $ew_score) {
            my $notsplit = ($ns_score eq 'AVE'  && $ew_score eq 'AVE')  ||
                           ($ns_score eq 'AVE+' && $ew_score eq 'AVE-') ||
                           ($ns_score eq 'AVE-' && $ew_score eq 'AVE+');
            if (! $notsplit) {
              # Rare case of an adjusted score that is different for both sides.
              $ns_score = "$ns_score|$ew_score";
            }
          }
          elsif (!$ns_score) { $ns_score = -$ew_score; }
        }
        push @results, {'ns_score' => $ns_score, 'mp_ns' => $mp_ns, 'mp_ew' => $mp_ew,
          'pair_id_ns' => $pair_id_ns, 'pair_id_ew' => $pair_id_ew};
        # print "$hnum  $ns_score  $mp_ns  $pair_id_ns  $pair_id_ew\n";

      }
      $bdata{$hnum} = \@results;
    }
    elsif ($fline =~ /^EVENT>/) {
      # Read and save section information.
      my $have_player_nums = 0;
      chomp($fline);
      my (@textlines);
      push @textlines, $fline;
      my ($event, $session, $section) =
        $fline =~ /EVENT>(.+)\|SESSION>(.+)\|SECTION> (.+)/;
      $event =~ s/\s+$//;
      $session =~ s/\s+$//;
      my ($secname, $secdir) = split /\s+/, $section;
      if (!$secdir) {$secdir = '';}  # Howell movement (avoid warning later)
      if (! $have_evt_info) {
        $evt{'event'} = $event; $evt{'session'} = $session;
      }
      
      # For BAM, $inpairs really means in list of teams rather than listing of pairs.
      my ($inpairs, $pair_id, $additional_award);
      while ($fline = <FILE>) {
        chomp($fline);
        push @textlines, $fline;
        if (!$have_evt_info) {
          if ( $fline =~ /DATE>/ ) {
            ($evt{'datestr'}) = $fline =~ /DATE>(\w+ \d+, \d{4})/;
            ($evt{'lastmod'}) = $fline =~ /\|\s*(\d+\/\d+\/\d{4} \d+:\d{2})/;
          }
          if ( $fline =~ /CLUB>/ ) {
            # Get this field when ACBLscore is run in club mode.
            ($evt{'club'}) = $fline =~ /CLUB>(.+)/;
            $evt{'club'} =~ s/\s+$//;
            # Kludges for truncation of Pacific Southwest Regional
            $evt{'club'} =~ s/REGIONL/REGIONAL/;
            $evt{'club'} =~ s/Regiona/Regional/;      
          }
          if ( $fline =~ /CITY>/ ) {
            # Get this field when ACBLscore is run in tournament mode.
            ($evt{'city'}) = $fline =~ /CITY>([^|]+)/;
            $evt{'city'} =~ s/\s+$//;   
          }
          if ( $fline =~ /CLUB NO.>/ ) {
            # Get this field when ACBLscore is run in club mode.
            ($evt{'clubnum'}) = $fline =~ /CLUB NO.>(\d+)/;
          }
          if ( $fline =~ /DIR>/ ) {
            ($evt{'director'}) = $fline =~ /DIR> ([^|]+)/;
            $evt{'director'} =~ s/\s+$//
          }
          if ( $fline =~ /EVENT CODE>/ ) {
            # Get this field when ACBLscore is run in tournament mode.
            ($evt{'eventcode'}) = $fline =~ /EVENT CODE>\s*(\S+)/;
          }
          if ( $fline =~ /MP LIMITS>/ ) {
            # Get this field when ACBLscore is run in club mode.
            (my $mplimits) = $fline =~ /MP LIMITS>\s*(\S+)/;
            $evt{'mplimits'} = [ split /\//, $mplimits ];
          }
          if ( $fline =~ /MOVEMENT/ ) {
            ($evt{'movement'}) = $fline =~ /MOVEMENT>\s*(.*)\s*$/;
          }
          if ( $fline =~ /RATING>/ ) {
            # Get this field when ACBLscore is run in club mode.
            ($evt{'rating'}) = $fline =~ /RATING>([^|]+)/;
            $evt{'rating'} =~ s/\s+$//;
            # Strip "(50%, 50%, 30% Open)" and similar from "Club Masterpoint (50%, 50%, 30% Open)".
            $evt{'rating'} = 'Club Masterpoint' if $evt{'rating'} =~ /^Club Masterpoint /;
          }
          if ( $fline =~ /SANCTION>/ ) {
            # Get this field when ACBLscore is run in tournament mode.
            ($evt{'sanction'}) = $fline =~ /SANCTION>\s*(\S+)/;
          }
          if ( $fline =~ /TOURN>/ ) {
            # Get this field when ACBLscore is run in tournament mode.
            ($evt{'tournament'}) = $fline =~ /TOURN>(.+)/;
            $evt{'tournament'} =~ s/\s+$//;
            # Kludges for truncation of Pacific Southwest Regional
            $evt{'tournament'} =~ s/REGIONL/REGIONAL/;
            $evt{'tournament'} =~ s/Regiona$/Regional/;        
          }
          if ( $fline =~ /TOP>/ ) {
            ($evt{'top'}) = $fline =~ /TOP>\s*(\d+)/;
          }
          # Teams if BAM
          if ( $fline =~ /PAIRS|TEAMS>/ ) {
            $evt{'nstrats'} = 1; $evt{'strats'} = 'A';
          }
          if ( $fline =~ /(PAIRS|TEAMS) IN STRAT/ ) {
            (undef, my $strattallies) = $fline =~ /(PAIRS|TEAMS) IN STRAT\s*(\S+)/;
            $strattallies =~ s/=\d+\/?//g;
            $evt{'nstrats'} = length($strattallies); $evt{'strats'} = $strattallies;
          }
        }
        
        # Older ACBLscore versions included the player numbers. 
        if ( $fline =~ /^No         Name/ ) { $have_player_nums = 1; }
        if ( $fline =~ /^No         Name/ || $fline =~ /^No Name/ ) {
          # Figure out which columns we have for each pair (team if BAM) and where each one starts
          # and how wide it is. We can't do this just once for each Event (as with the information
          # above) because columns are not always the same for each section, e.g. one Section in
          # an Event has an Adjust column but the other Sections(s) do not. There are many tricky
          # cases:
          # 
          # - Events may be non-stratified or have two (e.g. A/X) or three (e.g. A/B/C strats)
          # - Strats sometimes have designations like D/E/F or 3/7
          # - Ranks can include ties e.g. 4/5, and Not Eligible (NE)
          # - Unstratified events just have a column 'Rank' instead of Rnk-A, Rnk-B etc.
          # - There is no percent (Pct) column for IMP Pairs because Pct has no meaning
          # - Awards can be a mix of masterpoint colors and be spread onto next row
          #   in the Award column
          # - There are columns like Adjust that only appear when needed and columns like
          #   Next Session that only appear in multiple session events.     
          
          %colpos = ();
          my $ix1 = index($fline, '|'); my $ix2; my ($colname, $ranknum, $rankname, $ranknameO);
          while ( ($ix2 = index($fline, '|', $ix1+1)) != -1 ) {
            ($colname = substr($fline, $ix1+1, $ix2-$ix1-1)) =~ s/\s+//g;
            if ( $colname eq 'SectTableDir' ) { $evt{'finalAwards'} = 0; }
            $evt{'isMultiSession'} = 1 if $colname eq 'Over' || $colname eq 'SectTableDir';
            $colname = 'Carryover' if $colname eq 'Over';
            ## print "colname: [$colname]\n";
            if ($colname eq 'Pct') { $evt{'hasPct'} = 1; }
            # Store start of column and column with in COLPOS. Include the character under the
            # Final | because ACBLscore sometimes puts data there when it is running in Club
            # Mode (probably a bug in ACBLscore).
            if ($colname !~ /^Rnk/ && $colname !~ /^Rank/) { $colpos{$colname} = [$ix1+1, $ix2-$ix1]; }
            else {
              # Ranks are trickier because they may be for Overall or Section and we want to
              # canonicalize the column names to Rnk#{O,S}, e.g Rnk2S for second highest rank
              # in section regardless of rank designators used (e.g. D/E/F). Note: Overall
              # ranks are always positioned before Section Ranks in ACBLscore reports.
              if ($colname =~ /^Rank/) { $ranknum = 1; }
              else { $ranknum = index($evt{'strats'}, substr($colname,-1)) + 1; }
              $rankname = 'Rnk' . $ranknum . 'S';
              if ( defined $colpos{$rankname} ) {
                # First time was actually an Overall Rank. Transfer column position.
                $ranknameO = 'Rnk' . $ranknum . 'O';
                $colpos{$ranknameO} = $colpos{$rankname};
                $evt{'hasOverallRanks'} = 1;
              }
              # Rank columns are at most five characters wide, e.g. an MM/NN tie.
              # Initially assume nominal column start at $ix+1.
              $colpos{$rankname} = [$ix1+1, 5];
              ## print "rankname: [$rankname]  [$colname]  ($colpos{$rankname}[0], $colpos{$rankname}[1])\n";
            }
            $ix1 = $ix2;
          }
          # Correct for ACBLscore formatting bugs that systematically shifts the center of the
          # Overall rank columns one character left when there are Overalls. The Section rank 
          # shift one character right if there is no Carryover column.
          if ( $evt{'hasOverallRanks'} ) {
            foreach $ranknum (1..length($evt{'strats'})) { 
              $rankname = 'Rnk' . $ranknum . 'O'; $colpos{$rankname}[0]--;
              next if defined $colpos{'Carryover'};
              $rankname = 'Rnk' . $ranknum . 'S'; $colpos{$rankname}[0]++;
            }
          }

          # If there is an Adjust column, the Awards column will include the character under the
          # leading | if the masterpoint awards is 10.00 or greater. This seems to be due to a
          # bug in the ACBLscore formatting of the Adjust column. Fix things up if necessary
          if (defined $colpos{'Adjust'}) { $colpos{'Awards'}[0]--; $colpos{'Awards'}[1]++; }
        }
        
        if ( $fline =~ /^( |\d)\d / ) {
          # Found pair number (team number if BAM) at start of line.
          # Parse Player names and player numbers if present.
          $inpairs = 1;
          (my $pair_num = substr($fline,0,2)) =~ s/ //;
          $pair_id = $secname . $pair_num . substr($secdir,0,1);
          
          if ($gametype eq 'BAM' && $pair_num > 1) {
            # Record player names from previous team.
            $py{$last_pair_id}{'players'} = [@pynames]; @pynames = ();
          }
          # Track this for BAM in case there is a skip team (like a skip pair).
          $last_pair_id = $pair_id;
          
          if ( $have_player_nums ) {
            # Parse player number. In this case, the user does not have to supply a game
            # file to use the -mp, -fs, and -fc switches.
            (my $player1 = substr($fline,11,22)) =~ s/\s+$//;
            (my $player2 = substr($fline,42,22)) =~ s/\s+$//;

            my $pnum1 = substr($fline,3,7);
            if ( $pnum1 =~ /^[0-9J-S][0-9]{6}$/ ) {
              my $val = ord(substr($pnum1,0,1));
              if ($val > 57) { $val -= 25; substr($pnum1,0,1) = chr($val); }
              $pnn{$player1} = $pnum1;
            }
            else { $pnum1 = undef; } 

            my $pnum2 = substr($fline,34,7);
            if ( $pnum2 =~ /^[0-9J-S][0-9]{6}$/ ) {
              my $val = ord(substr($pnum2,0,1));
              if ($val > 57) { $val -= 25; substr($pnum2,0,1) = chr($val); }
              $pnn{$player2} = $pnum2;
            }
            else { $pnum2 = undef; }
            
            if ($gametype eq 'pairs') {
              $py{$pair_id} = {'player1' => $player1, 'player2' => $player2,
                'pnum1' => $pnum1, 'pnum2' => $pnum2};
            }
            else {
              # BAM (where $PAIR_ID is really a team id)
              push @pynames, $player1, $player2;
            }
      
          }
          else {
            # May need to strip a trailing asterisk. Indicates a sitout for a 5+ person
            # BAM team (Edit/BAM Sitouts in ACBLscore)
            (my $player1 = substr($fline, 3,22)) =~ s/\s+\*?$//;
            (my $player2 = substr($fline,26,22)) =~ s/\s+\*?$//;
            if ($gametype eq 'pairs') {
              $py{$pair_id} = {'player1' => $player1, 'player2' => $player2};
            }
            else {
              # BAM (where $PAIR_ID is really a team id)
              push @pynames, $player1, $player2;              
            }
          }
          
          # Now parse Flt, Ranking, Pct, Score/Total, and Award as defined above.
          foreach my $colname (keys %colpos) {
            ## print "$pair_id $colname $colpos{$colname}[1] [", substr($fline, $colpos{$colname}[0], $colpos{$colname}[1]), "]\n";
            ($py{$pair_id}{$colname} = substr($fline, $colpos{$colname}[0], $colpos{$colname}[1])) 
              =~ s/\s*\|?//g;
            # Wipe out periods in Rank columns.
            $py{$pair_id}{$colname} = '' if $colname =~ /^Rnk/ && $py{$pair_id}{$colname} eq '.';

            if ($colname eq 'Awards' && $py{$pair_id}{'Awards'}  ne '') {
              if ( (my $loc = index($py{$pair_id}{'Awards'}, '(')) != -1 ) {
                # If Award has a reason indicator like '(OC)' (overall C Flt), extract that
                # and store it separately.
                $py{$pair_id}{'Reason'} = substr($py{$pair_id}{'Awards'}, $loc+1, -1);
                $py{$pair_id}{'Awards'} = substr($py{$pair_id}{'Awards'}, 0, $loc);
              }
              if ( $py{$pair_id}{'Awards'} !~ /\d$/ ) {
                # Add space between award amount and pigmentation.
                (my $awardmp, my $pigm) = $py{$pair_id}{'Awards'} =~ /([.\d]+)\s*([^0-9.]+)/;
                if ($pigm =~ /^\*+$/) {
                  # Correct for a "bug" in ACBLscore. When pigmentation would cause Award
                  # field to overflow the field is truncated and filled with asterisks instead,
                  # e.g. *** instead of Gold because Gold is one character too long. Examine
                  # event rating to guess at pigmentation. Note: this process ignores Nationals
                  # because I don't have sample ACBLscore output for those tournaments.
                  $pigm = $evt{'rating'} eq 'Regional' ? 'Gold' : 'Red';
                }    
                $py{$pair_id}{'Awards'} = "$awardmp $pigm";
              }
              elsif ($evt{'rating'} eq 'Sectional') {
                # Sectional awards are Silver when not otherwise marked.
                $py{$pair_id}{'Awards'} .= ' Silver';
              }
            }
          }
          
        }
        
        elsif ( $fline =~ /^\s+Totals\s+[0-9. ]+\s+/ ) {
          if ($gametype eq 'BAM') {
            # Record player names from previous team.
            $py{$last_pair_id}{'players'} = [@pynames]; @pynames = ();
          }
          # End of section information
          $sections{$secname}{$secdir} = \@textlines;
          $have_evt_info = 1; $inpairs = 0; last;       
        }
        
        elsif ($inpairs && length($fline) > $colpos{'Awards'}[0]) {
          # When a masterpoint award is split between colors, e.g. Gold and Red, part
          # of the award is noted on the next line.         
          $additional_award = substr($fline, $colpos{'Awards'}[0], $colpos{'Awards'}[1]);
          if (defined $additional_award && $additional_award =~ /\S/) {
            $additional_award =~ s/\s+//g;
            if ($additional_award !~ /\d$/) {
              # Same considerations as above.
              (my $awardmp, my $pigm) = $additional_award =~ /([.\d]+)\s*([^0-9.]+)/;
              if ($pigm =~ /^\*+$/) { $pigm = $evt{'rating'} eq 'Regional' ? 'Gold' : 'Red'; }
              $additional_award = "$awardmp $pigm";
            }
            $py{$pair_id}{'Awards'} .= ',' . $additional_award;          
          }
        }
        
        elsif ($inpairs && $gametype eq 'BAM' && length($fline) > 3 && substr($fline,3,46) =~ /\S/) {
          # This is a bit sloppy due to a lack of BAM samples. It assumes additional awards
          # (in the previous ELSIF) occur on a separate line from third and fourth teams
          # members (team members seem to be on every other line).
          my @loc = $have_player_nums ? (11, 42) : (3, 26);
          foreach my $loc (@loc) {
            (my $player = substr($fline,$loc,22)) =~ s/\s+$//;
            # Five person team will not have a sixth player.
            push @pynames, $player if $player =~ /\S/;
          }
        }
      }
    }
    else {
      # Check if problem is specifically due to trying to reprocess output
      # from ACBLscore.
      for my $i (1..3) { $fline = <FILE>; }
      close(FILE);
      if ($fline =~ /Created by ACBLmerge/) {
        print STDERR <<"END";

  Input result file is HTML previously created by ACBLmerge. This can not be
  used as input. Regenerate the original report from ACBLscore.
  
  Input file was: $fname
END
        return ($EXIT_REPROCESS_ERR);
      }
      else {
        print STDERR <<"END";
        
  Input file does not seem to be an ACBLscore traveler report. From within
  ACBLscore do: Reports (menu) --> Recap/Press (menu) > Screen/File (LR) -->
  2. File --> 8. Press + Recap (traveler format) to generate the correct
  format
  
  Input file was: $fname
END
        return ($EXIT_ACBLSCORE_PARSE_ERR);
      }
    }
  }
  close(FILE);
  if (scalar(keys %br) == 0) {
    my $errmsg =
      "  Input file does not seem to be an ACBLscore traveler report.\n" .
      "  Never saw any lines like 'RESULTS OF BOARD #'.\n" .
      "  Input file was: " . $fname;
    return($errmsg);
  }
  $evt{'sections'} = [sort keys %sections];
  
  return('', \%sections, \%evt, \%py, \%br, \%bdata, scalar(keys %pnn) ? \%pnn : undef);
}


sub readACBLscoreTeams {
  # Reads ACBLscore traveler report (either text or HTML format) for team games.
  # Extracts header fields (e.g. event, club, and date), players on each team,
  # and masterpoint award granted to each player. If player number are included,
  # also returns mapping of player names to player numbers so that ACBLscore in
  # which case the ACBLscore game file is not needed for this mapping. 
  #
  # Note: For HTML versions of its reports ACBLscore basically just slaps a <pre>
  # tag around text version. It fails to declare a <DOCTYPE>, include a <body>
  # tag (not to mention a <title>), or otherwise get the basics of HTML correct.
  # Sigh!
  
  my ($fname, $fline, @plines, $pline) = @_;
  
  my %evt = ('gametype', 'teams', 'final', 0, 'hasOverallRanks', 0);
  my (%pyteams, $teamnum, %pl, $pyname, @pynames, $award, $awardmp, $pigm);
  my ($pnum, %pnn);

  open(FILE, '<:crlf', $fname) or return("  Unable to open/read: $fname");

  my $have_player_nums = 0;
  while ($fline = <FILE>) {
    # Ignore any of the minimal HTML tags that ACBLscore writes if the input file
    # is an HTML report. Also ignore any pseudotags like <!A> (ACBLscore might only
    # write them for pairs results, but assume the worst.)
    if ($fline =~ /^\s*$/ ||  $fline =~ /^<![A-Z]+\d*>/ ||
        $fline =~ /^<html>\s*<pre>$/ || $fline =~ /^<\/pre>\s*<\/html>$/) { next; }
    # Masterpoints are awarded on the final round.
    if ($fline =~ /^\s*No\s*Name\s*\|\s*Points\s*/ ) { $evt{'final'} = 1; }
    
    # Teams start below the "No Name" line.
    if ($fline =~ /^\s*No Name/ ) { last; }
    if ($fline =~ /^\s*No         Name/) { $have_player_nums = 1; last; }
    
    if ( $fline =~ /BDS\/RD>/ ) {
      ($evt{'boardsPerRound'}) = $fline =~ /BDS\/RD>(\d+)/;
      $evt{'boardsPerRound'} =~ s/\s+$//;
    }
    if ( $fline =~ /CITY>/ ) {
      # Get this field when ACBLscore is run in tournament mode.
      ($evt{'city'}) = $fline =~ /CITY>([^|]+)/;
      $evt{'city'} =~ s/\s+$//;
    }
    if ( $fline =~ /CLUB>/ ) {
      # Get this field when ACBLscore is run in club mode.
      ($evt{'club'}) = $fline =~ /CLUB>(.+)/;
      $evt{'club'} =~ s/\s+$//;
    }
    if ( $fline =~ /CLUB NO.>/ ) {
      # Get this field when ACBLscore is run in club mode.
      ($evt{'clubnum'}) = $fline =~ /CLUB NO.>(\d+)/;
    }
    if ( $fline =~ /DATE>/ ) {
      ($evt{'datestr'}) = $fline =~ /DATE>(\w+ \d+, \d{4})/;
    }
    if ($fline =~ /GAME>/) {
      ($evt{'gameformat'}) = $fline =~ /GAME>(.+)/;
      $evt{'gameformat'} =~ s/\s+$//;
    }
    if ($fline =~ /^EVENT>/) {
      ($evt{'event'}) = $fline =~ /EVENT>(.+)\|/;
      $evt{'event'} =~ s/\s+$//;
    }
    if ( $fline =~ /EVENT CODE>/ ) {
      # Get this field when ACBLscore is run in tournament mode.
      ($evt{'eventcode'}) = $fline =~ /EVENT CODE>\s*(\S+)/;
    }
    if ( $fline =~ /MP LIMITS>/ ) {
      # Get this field when ACBLscore is run in club mode.
      (my $mplimits) = $fline =~ /MP LIMITS>\s*(\S+)/;
      $evt{'mplimits'} = [ split /\//, $mplimits ];
    }
    if ( $fline =~ /RATING>/ ) {
      # Get this field when ACBLscore is run in club mode.
      ($evt{'rating'}) = $fline =~ /RATING>([^|]+)/;
      $evt{'rating'} =~ s/\s+$//;
      # Strip "(50%, 50%, 30% Open)" and similar from "Club Masterpoint (50%, 50%, 30% Open)".
      $evt{'rating'} = 'Club Masterpoint' if $evt{'rating'} =~ /^Club Masterpoint /;
    }    
    if ( $fline =~ /SANCTION>/ ) {
      # Get this field when ACBLscore is run in tournament mode.
      ($evt{'sanction'}) = $fline =~ /SANCTION>\s*(\S+)/;
    }
    if ( $fline =~ /TOURN>/ ) {
      # Get this field when ACBLscore is run in tournament mode.
      ($evt{'tournament'}) = $fline =~ /TOURN>(.+)/;
      $evt{'tournament'} =~ s/\s+$//;
    }    
  }

  # Blow off first line of dashes after "No Name" column header.
  $fline = <FILE>;
  while ($fline = <FILE>) {
    if ($fline =~ /\sTOTALS\s/ ) { last; }
    if ($fline !~ /^- - - - /) { push @plines, $fline; next; }
    
    # Parse player names and team number. Teams can have up to six members and
    # ACBL output may optionally include the city for each player beneath the
    # player name. There will be two or three lines if cities are not included
    # and four or six if they are.
    my $dx = $#plines < 3 ? 1 : 2;
    $evt{'hasCities'} = $#plines > 2;
    for (my $ix=0; $ix<=$#plines; $ix+=$dx) {
      $pline = $plines[$ix];
      if ( substr($pline,0,3) =~ /\d+/ ) {
        ($teamnum = substr($pline,0,3)) =~ s/\s+//g;
      }
      
      my @namepos = $have_player_nums ? (12,52) : (4,36);
      $namepos[1] -= 9 if ! $evt{'final'};

      foreach my $loc (@namepos) {
      # Strip whitespace from end of player's full name and deal with teams that
      # have an odd number of players (right column should be the empty one, but
      # check both just in case).
      ($pyname = substr($pline,$loc,22)) =~ s/\s+$//;
        if ($pyname ne '') {
          push @pynames, $pyname;
          if ($have_player_nums) {
            $pnum = substr($pline,$loc-8,7);
            if ($pnum =~ /[0-9J-R][0-9]{6}/) {
              my $val = ord(substr($pnum,0,1));
              if ($val > 57) { $val -= 25; substr($pnum,0,1) = chr($val); }
              $pnn{$pyname} = $pnum;
            }
          }
          
          if ( $evt{'final'} ) {
            # Parse masterpoint award. This has to be parsed separately for each team
            # member because if the team has more than four members the award can vary
            # for each member if they played significantly different amounts.
            ($award = substr($pline,$loc+22,9)) =~ s/\s+$//;
            
            if ($award eq '') { $pl{$pyname}{'Award'} = ''; }
            else {
              if ( (my $ploc = index($award, '(')) != -1 ) {
                # If Award has a reason indicator like '(OC)' (overall C Flt), extract that
                # and store it separately.
                $pl{$pyname}{'Reason'} = substr($award, $ploc+1, -1);
                $award = substr($award, 0, $ploc);
              }
              
              # Add space between award amount and pigmentation.
              ($awardmp, $pigm) = $award =~ /([.\d]+)\s*([^0-9.]*)/;
              # ACBLscore would run out of space for awards of 10+ MP so it abbbreviates. 
              $pigm = 'Gold' if $pigm eq 'Gld';
              $pl{$pyname}{'Award'} = $awardmp . ($pigm ? " $pigm" : '');
              if ( $evt{'hasCities'} ) {
                # There may be an additional award on the second line. This happens when
                # the pigmentation is split. But watch out for text like '(2 wins)'
                ($award = substr($plines[$ix+1], $loc+22, 9)) =~ s/\s+$//;
                if ($award =~ /\.\d\d/ ) {
                  ($awardmp, $pigm) = $award =~ /([.\d]+)\s*([^0-9.]+)/;
                  $pigm = 'Gold' if $pigm eq 'Gld';
                  $pl{$pyname}{'Award'} .= ",$awardmp" . ($pigm ? " $pigm" : '');
                }       
              }
            }
          }
        }
      }
    }
    if ($teamnum !~ /^\d+$/) {
      # Should never happen... but be on guard.
      print STDERR "Failed to parse a team number for team with players: ",
      join(', ', @pynames), "\n";
    }
    $pyteams{$teamnum} = [@pynames];
    @plines = (); @pynames = (); $teamnum = undef;
  }
  
  close(FILE);
  return ('', \%evt, \%pyteams, \%pl, scalar(keys %pnn) ? \%pnn : undef);
}

sub readGIB {
  # Read Goren in a Box (GIB) library format.
  my ($fname) = @_,
  my %hd;
  if (!open(FILE, '<:crlf', $fname)) {
    print STDERR "Unable to open/read: $fname\n"; exit($EXIT_FILE_ERR);
  }
  my $hnum = 0;
  while (my $fline = <FILE>) {
    chomp($fline);
    $hnum++;
    my @fd = split /:/, $fline;
    my @hands = split /\s+/, $fd[0];
    $hd{$hnum} = {west => $hands[0], north => $hands[1],
		  east => $hands[2], south => $hands[3], dd => $fd[1]};
  }
  close(FILE);
  return \%hd;
}

sub writeGIB {
  # Write Goren in a Box (GIB) library format.
  my ($fname, $phd) = @_;
  my %hd = %$phd;
  if (!open(FILE, '>', $fname)) {
    print STDERR "Unable to open/write: $fname\n"; exit($EXIT_FILE_ERR);
  }
  if ( $opt{'crlf'} ) { binmode(FILE, ':crlf'); }
  foreach my $hnum (sort {$a <=> $b} keys %hd) {
    print FILE join(' ', ($hd{$hnum}{'west'}, $hd{$hnum}{'north'},
      $hd{$hnum}{'east'}, $hd{$hnum}{'south'}) ), ':';
    if ($hd{$hnum}{'dd'}) {
      print FILE $hd{$hnum}{'dd'}, "\n";
    }
    else {
      print FILE '-' x 20, "\n";
    }
  }
  close(FILE);
}

sub monthNum {
  # Return number of month.
  my ($monthName) = @_;
  my %monthNumMap = (January => 1, February => 2, March => 3, April => 4, 
		  May => 5, June => 6, July => 7, August => 8, September => 9,
		  October => 10, November => 11, December => 12);
  return $monthNumMap{$monthName};
}

sub monthMMM {
  # Returns three letter month abbreviation for month number (1-12)
  my ($mon) = @_;
  die "Month number must be in range 1-12." if !defined $mon || $mon < 1 || $mon > 12;
  my @mmm = ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
    'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'); 
  return $mmm[$mon-1];
}

sub readPBN {
  # Read Portable Bridge Notation (PBN) file format.
  # See: http://www.tistis.nl/pbn/
  # This is not a full parser; it just reads the board number, deal, and
  # double dummy results if present in the variant DoubleDummyTricks tag
  # written by Dealmaster Pro and Bridge Composer.
  my ($fname) = @_;
  my (%hd, $hnum, $deal, $dd, $parsingDD);
  if (!open(FILE, '<:crlf', $fname)) {
    print STDERR "Unable to open/read: $fname\n"; exit($EXIT_FILE_ERR);
  }
  
  # For parsing double dummy results in OptimumResultTable tag
  my %seats = ('E' => 0, 'S' => 1, 'W' => 2, 'N' => 3);
  my %denoms = ('NT' => 0, 'S' => 1, 'H' => 2, 'D' => 3, 'C' => 4);

  while (1) {
    my $fline = <FILE>;
    # Deals are separated by lines of arbitary whitespace.
    if ( !defined $fline || $fline =~ /^\s*$/ ) {
      # Ignore extra white space at the end of the file.
      if (!defined $hnum && !defined $deal) {
        if (!defined $fline) { last; }
        next;
      }
      
      # Record hand if both [Board] and [Deal] tags were found.
      if (!defined $hnum) {
				print STDERR "PBN record for following deal is missing deal number: $deal.\n";
				exit($EXIT_PBN_PARSE_ERR);
      }
      if (!defined $deal) {
				print STDERR "PBN record for hand $hnum is missing deal.\n";
				exit($EXIT_PBN_PARSE_ERR);
      }
      if ($hnum !~ /^\d+$/) {
      	print STDERR "PBN record has nonnumeric deal number: $hnum\n";
      	exit($EXIT_PBN_PARSE_ERR);
      }

      my @hands = split / /, substr($deal,2);
      # PBN notation can start with any hand, but then goes clockwise.
      (my $fhand = substr($deal,0,1)) =~ tr/wnes/WNES/;
      my $woff = ($fhand eq 'W') ? 0 : ($fhand eq 'S') ? 1 : ($fhand eq 'E') ? 2 :
				($fhand eq 'N') ? 3 : -1;
      if ($woff == -1) {
				print STDERR "PBN deal does not start with W,N,E, or S: $fhand\n";
				exit($EXIT_PBN_PARSE_ERR);
      }
      
      $hd{$hnum} = {west => $hands[$woff], north => $hands[($woff+1) % 4],
		    east => $hands[($woff+2) % 4], south => $hands[($woff+3) % 4], dd => $dd };

      $hnum=undef; $deal=undef; $dd=undef;
      if (!defined $fline) { last; }
    }
    else {
      chomp($fline);
      if ($fline !~ /^\[/) {
        if ($parsingDD) {
          my ($seat, $denom, $ntricks) = split /\s+/, $fline;
          if (defined $ntricks && $ntricks >=0 && $ntricks <= 13 && int($ntricks) == $ntricks &&
            defined $seats{$seat} && defined $denoms{$denom} ) {
            if ($seat eq 'E' || $seat eq 'W') { $ntricks = 13 - $ntricks; }
            substr($dd, 4*$denoms{$denom} + $seats{$seat}, 1) = 
              $ntricks < 10 ? chr(48 + $ntricks) : chr(55 + $ntricks);
          } 
        }
        next;
      }
      # Parse tag pair.
      my ($tag, $value) = $fline =~ /^\[(\S+) \"(.*)\"\]/;
      $parsingDD = 0;
      if ($tag eq 'Board') { $hnum = $value; }
      if ($tag eq 'Deal')  { $deal = $value; }
      if ($tag eq 'OptimumResultTable')  { $parsingDD = 1; $dd = '-' x 20; }
    }
  }
  close(FILE);
  return \%hd;
}

sub writePBN {
  # Write Portable Bridge Notation (PBN) format.
  # See: http://www.tistis.nl/pbn/ for documentation of the PBN format.
  my ($fname, $phd, $evt) = @_;
  my %hd = %$phd;

  # Convert date string from ACBLscore into YYYY.MM.DD format for PBN.
  my @fd = split /[\s,]+/, $evt->{'datestr'};
  my $YYYYMMDD = sprintf '%04d.%02d.%02d', $fd[2], monthNum($fd[0]), $fd[1];

  # Used for writing out double dummy results.
  my @denoms = ('NT', 'S', 'H', 'D', 'C');
  my @seats  = ('E', 'S', 'W', 'N');
  my $ntricks;

  my $fh;
  if (!open($fh, '>', $fname)) {
    print STDERR "Unable to open/write: $fname\n"; exit($EXIT_FILE_ERR);
  }
  if ( $opt{'crlf'} ) { binmode($fh, ':crlf'); }
  print $fh "% Generated by ACBLmerge.pl (Matthew Kidd, San Diego, CA)\n";
  if (defined $evt->{'clubnum'}) {
    print $fh "% Results for ACBL Club Number $evt->{'clubnum'}\n";
  }
  my $eventName = $opt{'pbnevt'} ? $opt{'pbnevt'} : $evt->{'event'};
  my $site = $evt->{'club'} ? $evt->{'club'} : $evt->{'tournament'} ?
    $evt->{'tournament'} . ' (' . $evt->{'city'} . ')' : undef;
  
  foreach my $hnum (sort {$a <=> $b} keys %hd) {
    my ($dlr, $vul) = dealerVul($hnum);
    # Convert N-S and E-W to NS and EW respectively for PBN compliance.
    $vul =~ s/-//;
    # Write the Identification Section.
    print $fh '[Event "', $eventName, '"]', "\n";
    if ($site) {
      print $fh '[Site "', $site, '"]', "\n";
    }
    print $fh '[Date "',   $YYYYMMDD, '"]', "\n";
    print $fh '[Board "',  $hnum, '"]', "\n";
    print $fh '[Dealer "', substr($dlr,0,1), '"]', "\n";
    print $fh '[Vulnerable "', $vul, '"]', "\n";
    print $fh '[Deal "', 'W:', 
    join(' ', ($hd{$hnum}{'west'}, $hd{$hnum}{'north'}, $hd{$hnum}{'east'},
	       $hd{$hnum}{'south'}) ), '"]', "\n";
    print $fh '[Scoring "MP"]', "\n";
    my $dd = $hd{$hnum}{'dd'};
    if (defined $dd && $dd !~ /-/) {
      # Include double dummy results
      print $fh '[OptimumResultTable "Declarer;Denomination\2R;Result\2R"]', "\n";
      for my $denom (0..4) {
        for my $seat (0..3) {
          $ntricks = hex substr($dd, $denom*4 + $seat, 1);
          if ($seat == 0 || $seat == 2) { $ntricks = 13 - $ntricks; }
          printf $fh "%s %2s %2d\n", $seats[$seat], $denoms[$denom], $ntricks;
        }
      }
    }

    # An empty line (or one with just whitespace) must separate each board.
    print $fh "\n";
  }
  close($fh);
}

sub writeLIN {
  # Write hands in Bridge Base LIN format.
  # Bridge Base has not released an official standard. This output is believed
  # to be compliant.
  my ($fname, $phd, $evt) = @_;
  my %hd = %$phd;

  my $fh;
  if (!open($fh, '>', $fname)) {
    print STDERR "Unable to open/write: $fname\n"; exit($EXIT_FILE_ERR);
  }
  if ( $opt{'crlf'} ) { binmode($fh, ':crlf'); }

  # Convert date string from ACBLscore into YYYY.MM.DD format for LIN.
  my @fd = split /[\s,]+/, $evt->{'datestr'};
  my $YYYYMMDD = sprintf '%04d.%02d.%02d', $fd[2], monthNum($fd[0]), $fd[1];

  my $eventName = $opt{'pbnevt'} ? $opt{'pbnevt'} : $evt->{'event'};
  my $site = $evt->{'club'} ? $evt->{'club'} : $evt->{'tournament'} ?
    $evt->{'tournament'} . ' (' . $evt->{'city'} . ')' : undef;

  print $fh "% Generated by ACBLmerge.pl (Matthew Kidd, San Diego, CA)\n";
  if (defined $evt->{'clubnum'}) {
    print $fh "% Results for ACBL Club Number $evt->{'clubnum'}\n";
  }
  print $fh "% $site - $YYYYMMDD - $eventName\n";

  my @hnums = sort {$a <=> $b} keys %hd;
  my $segment1 = "$YYYYMMDD - $eventName";
  my $segment2 = $site ? $site : '';
  # Vugraph title segments are limited to 45 and 19 characters respectively.
  # (maybe it is really 64 characters total. P = Pairs (game type)
    print $fh 'vg|', substr($segment1,0,45), ',', substr($segment2,0,19), 
    ',P,1,', $#hnums+1, ',', ($opt{'dd'} ? 'Par Bidders' : ''), ',,,|pg||', "\n";
  
  if ($opt{'dd'}) {
    # Assign par contracts to Team #1. Leave Team #2 contract blank. Equals sign
    # indicates a contract that makes exactly. X indicates a doubled contract.
    print $fh '% Par contracts', "\n";
    print $fh 'rs|';
    foreach my $hnum (@hnums) {
      # Use first par contract if there are multiple par contracts. Could try to
      # do something more sophisticated such as preferring contracts that make.
      my $contract = defined $phd->{$hnum}{'par_contracts'} ?
        $phd->{$hnum}{'par_contracts'}[0] : undef;
      if ($contract) {
        if (index($contract, '*') == -1) {
          # Making contract. Use first seat, e.g. 3N-EW -> 3NE=
          $contract = substr($contract,0,2) . substr($contract,3,1) . '=';
        }
        else {
          # Sacrifice contract. Use first seat, e.g. 5C*-NS-3 -> 5CNX-2
          $contract = substr($contract,0,2) . substr($contract,4,1) . 'X' .
            substr($contract,-2);
        }
        print $fh $contract;
      }
      print $fh ',,';
    }
    print $fh "|\n";
  }
  
  if (0) {
    # These fields seem to cause problems or are being used improperly.
    # Write list of board numbers.
    print $fh 'bn|', join(',', @hnums), '|', "\n";
    # It seems like the 'mn|' value should be followed by a new line before writing
    # the first hand, but my reference example does not have a newline there.
    print $fh 'mn|', $eventName, ' - ', $YYYYMMDD, '|';
  }
  
  my ($hnum, $dlr, $vul, $seat, @suits, $i);
  my $suitletters = 'SHDC';
  foreach $hnum (@hnums) {
    ($dlr, $vul) = dealerVul($hnum);
    print $fh 'qx|o', $hnum, '|st||rh||ah|', 'BOARD ', $hnum, '|md|';
    # The hand is preceded by the dealer. 1 = South, 2 = West, 3 = North, 4 = East
    print $fh $dlr eq 'South' ? 1 : $dlr eq 'West' ? 2 : $dlr eq 'North' ? 3 : 4;
    # Hand format is like S95HT82DJ75CJ7542, i.e. suit symbols followed by cards.
    # Only need to write first three hands because LIN format assumes fourth hand
    # contains the missing cards.
    foreach $seat ('south', 'west', 'north') {
      @suits = split /\./, $hd{$hnum}{$seat};
      for ($i=0; $i<4; $i++) {
        print $fh substr($suitletters,$i,1), defined $suits[$i] ? $suits[$i] : '';
      }
      print $fh ',' if $seat ne 'north';
    }
    # LIN format uses 0, n, e, b for vulnerability designations.
    # Also add the '|pg||nt||' cruft (pg = page break).
    if ($vul eq 'None') { $vul = '0'; } else { $vul = chr(ord(substr($vul,0,1))+32); }
    print $fh '|sv|', $vul, "|pg||nt||\n";
  }
  close($fh);  
   
}

sub readDUP {
  # Read Duplimate file.
  my ($fname) = @_;
  my %hd;

  if (!open(FILE, $fname)) {
    print STDERR "Unable to open/read: $fname"; exit($EXIT_FILE_ERR);
  }
  
  my $rank = 'AKQJT98765432';
  my @seats = ('north', 'east', 'south');
  my $hnum = 0; my ($data1, $data2);
  while (1) {
    last if read(FILE, my $data1, 79) != 79;

    $hnum++;
    if (substr($data1,-1) ne ' ' && substr($data1,-1) ne "\000") {
      # New style Duplimate (DUP) format.
      last if read(FILE, my $data2, 67) != 67;

      my @suits = split /[\x03-\x06]/, $data2;
      # Suppress a warning caused by voids in lowest suit(s) of last hand (west)
      # when join() is called.
      for my $i (0..15) { if (!defined $suits[$i]) { $suits[$i] = ''; } }
  
      $hd{$hnum} = {north => join('.', @suits[0..3]),
  		  east  => join('.', @suits[4..7]),
  		  south => join('.', @suits[8..11]),
  		  west  => join('.', @suits[12..15]) };
  	  
      # It is not clear what the next 10 bytes represent.
      # Typically looks like: "YN1  1 16 "
  	  last if !seek(FILE, 10, 1); 
    }
    else {
      # Old style Duplimate (BRI) format. Encodes each hand as the 13 cards
      # dealt to North, East, and South (remainder assumed to belong to West)
      # as two ASCII digits per card 01 = Spade A, 02 = Spade K, 14 = Heart A,
      # etc.
      my $cardsLeft = $rank x 4;
      my ($offset, $ix, $suit, $suitix);
      foreach (my $i=0; $i <= $#seats; $i++) {
        my @suits = ('') x 4;
        $offset = 26 * $i;
        for (my $j=0; $j < 26; $j += 2) {
          $ix = substr($data1, $offset+$j, 2);
          if ( $ix !~ /\d\d/ || $ix < 1 || $ix > 52 ) {
            print STDERR <<"END";
            
Error parsing old style Duplimate format. Expected a number between 1 and 52
for a card but received "$ix". \$i was $i and \$j was $j. \$data1 was:
  
$data1

END
            exit($EXIT_BRI_PARSE_ERR);
          }
          $ix--;
          substr($cardsLeft, $ix, 1) = ' ';
          $suit = int($ix / 13);
          $suitix = $ix % 13;
          $suits[$suit] .= substr($rank, $suitix, 1);
        }
        $hd{$hnum}{$seats[$i]} = join('.', @suits);
      }
      (my $spades = substr($cardsLeft, 0,  13)) =~ s/ //g;
      (my $hearts = substr($cardsLeft, 13, 13)) =~ s/ //g;
      (my $diams  = substr($cardsLeft, 26, 13)) =~ s/ //g;
      (my $clubs  = substr($cardsLeft, 39, 13)) =~ s/ //g;

      $hd{$hnum}{'west'} = join('.', $spades, $hearts, $diams, $clubs);
      
      last if !seek(FILE, 49, 1);
    }
  }
  close(FILE);
  return \%hd;
}

sub readBWS {
  # Read Bridgemate / BridgePad / BridgeScorer BWS file.
  if (scalar(@_) != 1) { die "function requires 1 argument."; }
  my ($fname) = @_;

  if (!-f $fname) { return "File does not exist: $fname"; }

  my ($bsc, $brn, $bws);
  my $ctrcnt = 0; my $leadcnt = 0;
  
  if ($^O eq 'MSWin32') {
    requirePackage('DBI', 'Reading Bridgemate / BridgePad / BridgeScorer file');
    requirePackage('DBD::ODBC', 'Reading Bridgemate / BridgePad / BridgeScorer file');
    
    my $dsn = "driver=Microsoft Access Driver (*.mdb);dbq=$fname";
    my $dbh = DBI->connect("dbi:ODBC:$dsn", {ReadOnly => 1, PrintError => 0});
    
    if (!$dbh) { return "Database open for $fname failed. Was it a BWS file?\n" . DBI->errstr; }
    
    my $sql;
    $sql = "select * from Section";
    $bsc = $dbh->selectall_hashref($sql, ['Letter']);
    return "Database query failed: $sql\n" . $dbh->errstr if $dbh->err;
    
    $sql = "select * from RoundData";
    $brn = $dbh->selectall_hashref($sql, ['Section', 'NSPair']);
    return "Database query failed: $sql\n" . $dbh->errstr if $dbh->err;
    
    $sql = "select * from ReceivedData";
    $bws = $dbh->selectall_hashref($sql, ['Section', 'Board', 'PairNS']);
    return "Database query failed: $sql\n" . $dbh->errstr if $dbh->err;  
    
    $sql = "select count(*) from ReceivedData where Contract <> ''";
    ($ctrcnt) = $dbh->selectrow_array($sql);
    return "Database query failed: $sql\n" . $dbh->errstr if $dbh->err;  
  
    $sql = "select count(*) from ReceivedData where LeadCard <> ''";
    ($leadcnt) = $dbh->selectrow_array($sql);
    return "Database query failed: $sql\n" . $dbh->errstr if $dbh->err; 
    
    $dbh->disconnect;
  }
  else {
    # Rely on mdb-export program from mdbtools package on non-Windows platforms.
    my ($data, $colnames, $rownum, $row);
    ($data, $colnames) = mdbReadTable($fname, 'Section');
    while ( ($rownum, $row) = each %$data ) { $bsc->{$row->{'Letter'}} = $row; }
    
    ($data, $colnames) = mdbReadTable($fname, 'RoundData');
    while ( ($rownum, $row) = each %$data ) {
      $brn->{$row->{'Section'}}{$row->{'NSPair'}} = $row;
    }
    
    ($data, $colnames) = mdbReadTable($fname, 'ReceivedData');
    while ( ($rownum, $row) = each %$data ) {
      $bws->{$row->{'Section'}}{$row->{'Board'}}{$row->{'PairNS'}} = $row;
      $ctrcnt++ if $row->{'Contract'} ne '';
      $leadcnt++ if $row->{'LeadCard'} ne '';
    }
  }

  # Strip whitespace. Problems usually seems to be one or two trailing spaces
  # but try to guard against other cases too.
  foreach my $key (keys %$bsc) {
    (my $key2 = $key) =~ s/\s+//g;
    if ($key2 ne $key) { $bsc->{$key2} = delete $bsc->{$key}; }
  }
  
  # BridgePad stored the opening lead as value-suit instead of suit-value as
  # Bridgemate does. Convert BridgePad format to Bridgemate format for standard
  # handling.
  if ($leadcnt > 0) {
    my ($section, $bnum, $NSPair, $row, $lead);
    foreach $section (keys %$bws) {
      foreach $bnum (keys %{$bws->{$section}} ) {
        while ( ($NSPair, $row) = each %{$bws->{$section}{$bnum}} ) {
          $lead = $row->{'LeadCard'};
          if (substr($lead,-1) =~ /[CDHS]/) {
            $bws->{$section}{$bnum}{$NSPair}{'LeadCard'} = substr($lead,-1) . substr($lead,0,-1);
          }
        }
      }
    }
    
  }
  
  return('', $bws, $brn, $bsc, $ctrcnt ? 1 : 0, $leadcnt ? 1 : 0);
}

sub mdbReadTable {
  # Read a table from a JET database using mdb-export program of mdbtools package.
  if (scalar(@_) != 2) { die "function requires 2 arguments."; }
  my ($fname, $tname) = @_;
  
  my $mdbname = 'mdb-export';
  if ($^O eq 'darwin') {
    # On Mac, first check for mdb-export in the Mac OS X specific directory, otherwise
    # hope it is somewhere on the system search path.
    $mdbname = $MAC_OS_X_PATH . $mdbname if -x ($MAC_OS_X_PATH . $mdbname);
  }
  
  my $cmd = "\"$mdbname\" -Q \"$fname\" \"$tname\"";
  my $str = `$cmd`;
  if (${^CHILD_ERROR_NATIVE} != 0) {
    print <<"END";

  Failed to read \"$tname\" table from file $fname using mdb-export.
  The exit code was ${^CHILD_ERROR_NATIVE}.

  Maybe the mdbtools package is not installed on your system. On Ubuntu
  (Debian) you can install it via:

    apt-get install mdbtools       (if logged in as root)
    sudo apt-get install mdbtools  (if you have permission to install packages)
  
END

    exit($EXIT_MDB_READ_ERR);
  }
  
  my $rownum = 0;
  my (%data, @fd);
  open(my $fh, '<', \$str);
  my $fline = <$fh>;
  chomp($fline);
  my @colnames = split /,/, $fline;
  while (defined ($fline = <$fh>)) {
    chomp($fline);
    @fd = split /,/, $fline;
    $rownum++;
    for (my $i=0; $i<$#colnames; $i++) { $data{$rownum}{$colnames[$i]} = $fd[$i]; }
  }
  close($fh);

  return (\%data, \@colnames);
}

sub invokeDDsolver {
  # Invokes DDSOLVER double dummy solver. Currently this is only supported on
  # Windows and Mac OS X.
  my ($phd) = @_;
  my %hd = %$phd;
  
  my $DDSOLVER_BNAME = $^O eq 'MSWin32' ? 'ddsolver.exe' : 'ddsolver';
  # First check for ddsolver.exe executable in same directory as this script (Windows)
  # or in the OS specific directory (Mac). If so, use that version; otherwise hope it
  # is somewhere on the system search path.
  my $ddsolvername = ($^O eq 'MSWin32' ? $SCRIPTPATH : $MAC_OS_X_PATH) . $DDSOLVER_BNAME;
  if (! -x $ddsolvername) {
    # Program not found in same directory as ACBLmerge.pl (or Mac subdirectory)
    $ddsolvername = $DDSOLVER_BNAME;
  }

  my $tmpfnameIn  = appDir() . "ddsolver$$.in.tmp";
  my $tmpfnameOut = appDir() . "ddsolver$$.out.tmp";
  if ( !open(FILE, '>', $tmpfnameIn) ) {
    print STDERR "Unable to open/write temporary file: $tmpfnameIn\n";
    exit($EXIT_FILE_ERR);
  }

  my @hnums = sort {$a <=> $b} keys %hd;
  my $nhands = scalar(@hnums);

  # Create a temporary file to feed to DDSOLVER.
  foreach my $hnum (@hnums) {
    print FILE join(' ', ($hd{$hnum}{'west'}, $hd{$hnum}{'north'},
		     $hd{$hnum}{'east'}, $hd{$hnum}{'south'}) ),
    ":", '-' x 20, "\x0a";
  }
  close(FILE);
  
  my $cmd = "\"$ddsolvername\" \"$tmpfnameIn\" \"$tmpfnameOut\"";
  $cmd .= " -q" if $opt{'quiet'};
  my $rc = system($cmd);
  unlink($tmpfnameIn);
  
  if ( $rc == 0x100 ) {
    print STDERR <<"END";

  Command failed: $cmd
    
  The most likely reason is that the double dummy program ($DDSOLVER_BNAME) can
  not be found in the same directory as ACBLmerge.pl or on the system search
  path. Without $DDSOLVER_BNAME, double double analysis can not be performed.
END

    exit($EXIT_DDSOLVER_NOT_ON_PATH);
  }
  elsif ( $rc != 0 ) {
    print STDERR "\n  Command failed: $cmd\n\n  Error code: $rc\n";
    exit($EXIT_DDSOLVER_EXEC_ERROR);
  }
  
  my ($fh, $fline, $ddsolveWorks);
  if (! open($fh, '<', $tmpfnameOut)) {
    print STDERR "Unable to open/read: $tmpfnameOut\n";
    exit($EXIT_FILE_ERR); 
  }
  while ( $fline = <$fh> ) {
    my $hnum = shift @hnums;
    if ($fline =~ /^Error/) { next; }
    chomp($fline);
    if ($fline !~ /^[2-9AKQJT.]{16} [2-9AKQJT.]{16} [2-9AKQJT.]{16} [2-9AKQJT.]{16}:[0-9A-D]{20}$/ ) { last; }
    my @fd = split /:/, $fline;
    $hd{$hnum}{'dd'} = $fd[1];
    $ddsolveWorks = 1;
  }
  close($fh);
  unlink($tmpfnameOut);

  if (!$ddsolveWorks) {
    print STDERR "Warning: double dummy analysis seemed to have failed. No results found.\n";
  }
  return \%hd;
}

sub invokeDD {
  # Invokes DDD double dummy solver. This is supported for both Windows and other
  # platforms but has been superseded by invokeDDsolver() for Windows though
  # Windows support has not been removed from this subroutine.
  my ($phd) = @_;
  my %hd = %$phd;
  
  # Distinguishing between Windows and Unix like OSes (e.g. Linux and Mac OS)
  # is somewhat tricky. $ENV{'OS'} will probably not return 'Windows NT' on
  # all versions of Windows. Relying on $^0 is not clearcut either.
  my $iswindows = $ENV{'windir'};

  my $DDD_BNAME = 'ddd.exe';
  # First check for ddd.exe executable in same directory as this script.
  # If so, use that version; otherwise hope it is somewhere on the system
  # search path.
  my $dddname = $SCRIPTPATH . $DDD_BNAME;
  # Need to handle case where cwd ('.') is not on the PATH in Unix.
  if (!$SCRIPTPATH && !$iswindows) { $dddname = './' . $dddname; }
  
  if (! -x $dddname) {
    # Program not found in same directory as ACBLmerge.pl
    $dddname = $DDD_BNAME;
  }

  my $tmpfname = appDir() . "ddd$$.tmp";
  if ( !open(FILE, '>', $tmpfname) ) {
    print STDERR "Unable to open/write temporary file: $tmpfname\n";
    exit($EXIT_FILE_ERR);
  }
  binmode(FILE);

  my @hnums = sort {$a <=> $b} keys %hd;
  my $nhands = scalar(@hnums);

  # Create a temporary file to feed to DDD.exe  
  foreach my $hnum (@hnums) {
    print FILE join(' ', ($hd{$hnum}{'west'}, $hd{$hnum}{'north'},
		     $hd{$hnum}{'east'}, $hd{$hnum}{'south'}) ),
    ":", '-' x 20, "\x0a";
  }
  close(FILE);

  my $stime = time; my $etime;
  if ($opt{'ncpu'} == 1) {
    # Invoke ddd once to process all hands.
    my $cmd = "\"$dddname\" \"$tmpfname\" -giblib=1-$nhands-all";
    # Run at a lowered priority on Unix.
    if (!$iswindows) { $cmd = "nice -n $DDD_UNIX_NICE " . $cmd; }
    
    # Determining whether a pipe has been opened successfully is unreliable
    # in Perl, so we will check based on whether there is useful output. Also
    # check elapsed time since Ctrl-C can exit ddd.exe returning control to
    # before the pipe has made any results available to Perl due to buffering.
    my $dddworks = 0;
    open(DPIPE, "$cmd |");
    while ( my $fline = <DPIPE> ) {
      # Look for line like: deal=1 nodes=2,833,013 elapsed=8.20 totalelapsed=8.20
      if ( $fline !~ /totalelapsed/ ) { next; };
      $fline = <DPIPE>;
      chomp($fline);
      # Parse line like: tricks=9292A9A9424299995252
      my $hnum = shift @hnums;
      my @fd = split /\s+/, $fline;
      $hd{$hnum}{'dd'} = substr($fd[1], 7);
      $dddworks = 1;
    }
    $etime = time - $stime;
    close(DPIPE);
    unlink($tmpfname);
  
    if (!$dddworks && $etime <= 1) {
      print STDERR <<"END";
      
  It looks like the pipe below was not opened successfully:
  
    $cmd |
  
  Usually this means the double dummy driver (ddd.exe) can not be
  found in the same directory as ACBLmerge.pl or on the system
  search path. Without ddd.exe, double double analysis can not be
  performed.
END
      exit($EXIT_DDD_NOT_ON_PATH);
    }
  }
  else {
    # invoke ddd separate for each hand with a maximum of $opt{'ncpu'}
    # instances of ddd running concurrently.
    
    my $idx = 0;
    # Kick off first round of threads.
    for my $i (1..$opt{'ncpu'}) {
      $idx++;
      my $hnum = shift(@hnums);
      if (! $hnum) { last; }
      # {'context' => 'list'} means thread returns a list (not a scalar).
      threads->create({'context' => 'list'},
    		  \&invokeDD1, $hnum, $idx, $dddname, $tmpfname );
    }
    
    my $nthrJoined = 0;
    while (1) {
      # 0 is the same as threads::joinable. Use 0 for compatibility
      # with older version of Perl (e.g. 5.8) since threads::joinable
      # is not defined until Perl 5.10.
      my @thr = threads->list(0);
      foreach my $th (@thr) {
        my ($errmsg, $hnum, $tidx, $cmd, $ddstr) = $th->join();
        $nthrJoined++;
        if ($errmsg) {
          if ($errmsg eq 'pipe error') {
            print STDERR <<"END";
  
  It looks like the pipe below was not opened successfully:
  
    $cmd |
     
  Usually this means the double dummy driver (ddd.exe) can not be
  found in the same directory as ACBLmerge.pl or on the system
  search path. Without ddd.exe, double double analysis can not be
  performed.
  
END
          }
          else {
            print STDERR "\nddd.exe seems to have been started but " .
             "did not return the expected output for hand $hnum\n\n";
          }
          exit($EXIT_DDD_PARSE_ERR);
        }
        
        $hd{$hnum}{'dd'} = $ddstr;
        if (! $opt{'quiet'} ) {
          $etime = time - $stime; 
          printf STDERR chr(13) .
            "Double dummy analysis completed for %d board%s in %d m %d s " .
            "(%0.1f sec/board ave)", $nthrJoined, $nthrJoined == 1 ? '' : 's',
            ($etime/60), ($etime % 60), ($etime/$nthrJoined);
        }
        
        # Kick off processing for next hand (if there is one).
        $hnum = shift(@hnums);
        if ($hnum) {
          $idx++;
          threads->create({'context' => 'list'},
    		      \&invokeDD1, $hnum, $idx, $dddname, $tmpfname );
        }
      }
      if ($nthrJoined == $nhands) { last; }
      sleep(1);
    }
    print STDERR chr(13), "\n";
    unlink($tmpfname);
  }

  return (\%hd, $etime);
}

sub invokeDD1 {
  # Runs ddd for a single hand.
  # HNUM is the hand number. IDX is the index of the hand number. Normally these
  # will be the same but that will not be the case if some hand numbers are skipped.
  my ($hnum, $idx, $dddname, $giblibfname) = @_;
  
  my $iswindows = $ENV{'windir'};
  my $cmd = "\"$dddname\" \"$giblibfname\" -giblib=$idx-$idx-all";
  # Run at a lowered priority on Unix.
  if (!$iswindows) { $cmd = "nice -n $DDD_UNIX_NICE " . $cmd; }
  
  # Determining whether a pipe has been opened successfully is unreliable
  # in Perl, so we will check based on whether there is useful output.
  my $stime = time;
  my $dddworks = 0; my $ddstr;
  open(DPIPE, "$cmd |");
  while ( my $fline = <DPIPE> ) {
    # Look for line like: deal=1 nodes=2,833,013 elapsed=8.20 totalelapsed=8.20
    if ( $fline !~ /totalelapsed/ ) { next; };
    $fline = <DPIPE>;
    chomp($fline);
    # Parse line like: tricks=9292A9A9424299995252
    my @fd = split /\s+/, $fline;
    $ddstr = substr($fd[1], 7);
    $dddworks = 1;
  }
  close(DPIPE);
  my $etime = time - $stime;

  if (!$dddworks) {
    if ($etime <= 1) { return('ddd pipe error', $hnum, $idx, $cmd, undef); }
    return('missing result', $hnum, $idx, $cmd, undef);
  }
  return ('', $hnum, $idx, $cmd, $ddstr);
}

sub dealerVul {
  # Returns dealer and vulnerability for given board number.
  my ($hnum) = @_;
  # Order beginning at board 1, 17, 33, etc
  my @dealer_order = ('North', 'East', 'South', 'West');
  # Vulnerability order and where the order starts on boards 1, 5, 9, 13.
  my @vul_order = ('None', 'N-S', 'E-W', 'Both');

  $hnum--;
  $hnum %= 16;
  my $d4 = $hnum % 4;
  my $v4 = (($hnum / 4) + $d4) % 4;

  return ($dealer_order[$d4], $vul_order[$v4]);
}

sub writePlaintext {
  # Writes plaintext version of ACBL report. Useful when input file was
  # an HTML version.
  my ($sections, $br, $outfname) = @_;
   
  if (!open(OUT, '>', $outfname)) {
    print STDERR "Unable to open/write: $outfname\n"; exit($EXIT_FILE_ERR);
  }
  if ( $opt{'crlf'} ) { binmode(OUT, ':crlf'); }
   
  # Print out section information for all section, order by section designation
  # (e.g. A, B) with N-S before E-W (if Mitchell movement).
  foreach my $secname (sort keys %$sections) {
    foreach my $secdir (reverse sort keys %{$sections->{$secname}} ) {
      my @textlines = @{$sections->{$secname}{$secdir}};
      foreach my $tline (@textlines) { print OUT "$tline\n"; }
      print OUT "\n";
    }
  }
  
  foreach my $bnum (sort {$a <=> $b} keys %$br) {
    my @textlines = @{$br->{$bnum}};
    
    print OUT " RESULTS OF BOARD $bnum\n\n";
    print OUT "   SCORES      MATCHPOINTS   NAMES\n";
    print OUT "  N-S   E-W    N-S    E-W\n";
    foreach my $tline (@textlines) { print OUT "$tline\n"; }
    print OUT '-' x 70, "\n\n";
  }
  
  close(OUT);
}

sub HTMLheadstart {
  # Output start of HTML document. It would be better to use a filehandle
  # argument rather than global filehandle OUT.
  print OUT << "DONE";
<!DOCTYPE html>
<html lang="en">
<head>
<!-- Created by ACBLmerge $VERSTR (Matthew Kidd, San Diego, CA) -->
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
DONE
}

sub dumpHTMLpairs {
  # Create HTML output for pairs event. $DVC specifies the target device:
  # 'default' means create an ordinary webpage.
  if (scalar(@_) != 19) { die "function requires 17 arguments."; }  
  my ($dvc, $gametype, $evt, $sections, $br, $phd, $ppy, $pbdata, $outfname, $pnn, $pmp,
    $fsdata, $db_year, $db_mmm, $bsc, $bws, $bwsHasConts, $bwsHasLeads, $teamMP) = @_;
  my %hd; %hd = %$phd if defined $phd;
  my %py = %$ppy; my %bdata = %$pbdata;
  
  if ($dvc ne 'default' && $dvc ne 'iPhone') {
    die 'Target device must be "default" or "iPhone". Check code.';
  }

  if ($outfname) {
    if (!open(OUT, '>', $outfname)) {
      print STDERR "Unable to open/write: $outfname"; exit($EXIT_FILE_ERR);
    }
  }
  else {
    open(OUT, ">-");
  }
  if ( $opt{'crlf'} ) { binmode(OUT, ':crlf'); }
  
  # Determine the first section. Used when there is only one section.
  my @allSections = keys %$sections; my $singleSection = $allSections[0];

  # Write start of HTML document, i.e. <!DOCTYPE> and <meta> tags
  HTMLheadstart();

  if ($dvc eq 'iPhone') {
    print OUT '<meta name="viewport" content="320; initial-scale=1.0; ', 
      'maximum-scale=1.0;">', "\n";
  } 
  print OUT "<title>";
  if ($opt{'title'}) {
    print OUT $opt{'title'};
  }
  else {
    my @fd = split /\s+/, $evt->{'datestr'};
    # Chop month down to first three characters. This makes it more likely
    # that the day will also be visible if the user has many tabs open.
    my $datestr = join(' ', (substr($fd[0],0,3), $fd[1], $fd[2]));
    print OUT "$datestr Game Result";
  }
  print OUT "</title>\n";
  CSSheader('pairs');
  JSwindowname();
  JSoptions();
  JSredirect($opt{'iphfname'}) if $dvc eq 'default' && $opt{'iphone'} && $gametype ne 'BAM';
  
  # JSheader() writes the fixed Javascript code. JSvar() embeds the players
  # names and board results in Javascript arrays.
  JSheader('pairs');
  JSvars($evt, $singleSection, $ppy, $pbdata, $bsc, $bws, $bwsHasConts, $bwsHasLeads);
  
  # Insert optional user supplied content.
  insertFile($opt{'ih_fname'}) if $opt{'ih_fname'}; 
  print OUT "</head>\n\n";
  
  print OUT '<body>', "\n";
  # Insert optional user supplied content.
  insertFile($opt{'isb_fname'}) if $opt{'isb_fname'};
  
  print OUT '<div id="ACBLmerge">', "\n";
  print OUT '<div id="topinfo">', "\n";
  if (! $opt{'nohurl'}) {
    print OUT '<a class="nolinkunderline" href="',
    $opt{'hurl'} ? $opt{'hurl'} : $DEFAULT_HELP_URL, 
    '"><span class="help"><strong>?</strong></span></a>&nbsp;<a href="',
    $opt{'hurl'} ? $opt{'hurl'} : $DEFAULT_HELP_URL,
    '">Explanation of report features</a>&nbsp;&nbsp;', "\n";
  }
  
  # Write hyperlinks to various files (original txt, PBN, GIB, LIN, and PDF as appropriate)
  filelinkHTML();
  
  print OUT 'Jump directly to board', "\n";;
  foreach my $bnum (sort {$a <=> $b} keys %$br) {
    print OUT ' <a href="#board_results', $bnum, '">', $bnum, "</a>\n";
  }
  
  # Field strength colorbar
  fsHTML($fsdata) if defined $fsdata;
  
  # Checkbox for showing faces.
  if ($opt{'showfaces'}) {
    # Leave faces checkbox uncheck initially on the iPhone output because
    # the popups are likely to be unwieldy.
    my $checkattr = $dvc eq 'default' ? 'checked="checked"' : '';
    # value="dummy" satisfies overly picky HTML syntax checkers.
    print OUT <<"DONE";
<form action="#">
<input id="showfacesCB" name="showfacesCB" type="checkbox" $checkattr value="dummy">
<label for="showfacesCB">Show faces.</label>
</form>

DONE
  }
  
  print OUT '</div>', "\n";
  
  # Create a summary table of the masterpoint winners.
  dumpHTMLwinners($dvc, $evt, $ppy) if $opt{'listwinners'} && $gametype ne 'BAM';

  print OUT '<pre>',  "\n";

  # Print out section information for all section, order by section designation
  # (e.g. A, B) with N-S before E-W (if Mitchell movement).
  my $writtenOneSection = 0;
  
  # Starting in ACBLscore 7.60 (released Mar 21, 2009), the output no longer includes
  # the player numbers, the line with the player cities, and the blank line between
  # the section header and the first pair. This case has to be parsed differently for
  # the reformatted iPhone output.
  my $ACBLscore760orLater = 0;
  foreach my $secname (sort keys %$sections) {
    foreach my $secdir (reverse sort keys %{$sections->{$secname}} ) {
      # column separator positions and column types.
      my @cs = (0); my @ct = ('Flt'); my $inPairLines = 0;
      my @textlines = @{$sections->{$secname}{$secdir}};
      while ( defined (my $tline = shift(@textlines)) ) {
        if ( $tline =~ /^DATE>/ && $writtenOneSection ) {
          # Don't repeat >DATE and DIR> lines for each section.
          for my $i (1..3) { $tline = shift(@textlines); }
        }
        
        elsif ($dvc eq 'default') {
          if ($tline =~ /^No Name/ ) { $ACBLscore760orLater = 1; }
          if ( !$ACBLscore760orLater || $tline !~ /^\s*$/ ) {            
            $tline =~ s/>/&gt;/g;
            $inPairLines = 0 if ($tline =~ /^\s*Totals/);
            
            my @namepos = $ACBLscore760orLater ? (26, 3) : (42, 11);
            if ($tline =~ /^[0-9 ][0-9]/ || ($inPairLines && $gametype eq 'BAM' && $tline =~ /\S/) ) {
              # Line starts with a pair number or is an additional line of team members for a BAM game.
              $inPairLines = 1;
              if ($opt{'cgip'} || $opt{'mpdisplay'} || $opt{'showfaces'}) {
                # Add hovering JavaScript for tooltip to player names.
                # Need to do it "backwards" (player 2 before player 1)
                # because we are modifying $tline as we go.
                for my $ix (@namepos) {
                  (my $playerName = substr($tline,$ix,22)) =~ s/\s+$//;
                  # 6th player will be empty for 5 player BAM team.
                  next if $playerName !~ /\S/;
                  my $str = $playerName;
                  if ( $opt{'cgip'} ) {
                    my $url = $opt{'cgip'} . ( defined $pnn->{$playerName} ? 
                      '?pnum=' . $pnn->{$playerName} : '?pname=' . uri_escape($playerName) );
                    $str = '<a href="' . $url . '" class="hoverlink">' . $playerName . '</a>';
                  }
                  if ($opt{'mpdisplay'} || $opt{'showfaces'}) {
                    my $tooltip = '';
                    if ($opt{'mpdisplay'}) {
                      my $mp = $pnn->{$playerName} ? $pmp->{$pnn->{$playerName}} : undef;
                      if (defined $mp) {
                        $tooltip = 'Has ~' . approxMP($mp) . " masterpoints as of $db_mmm $db_year";
                      }
                    }
                    $str = '<span ' . tooltipjs($tooltip, $pnn->{$playerName}, $playerName) . '>' .
                      $str . '</span>';
                  }
                  substr($tline,$ix,22) = $str . ' ' x (22-length($playerName));  
                }
              }

              if ($gametype eq 'pairs') {
                # Insert hyperlink for pair's recap sheet, e.g. <a href="javascript:recap('I8N')">8</a>
                (my $pair_num = substr($tline,0,2)) =~ s/ //;             
                my $pair_id = $secname . $pair_num . substr($secdir,0,1);
                my $hlink = '<a href="javascript:recap(\'' . $pair_id . '\')">' .
                  $pair_num . '</a>';
                if ($pair_num < 10) { $hlink = ' ' . $hlink; }
                substr($tline,0,2) = $hlink;
              }
              elsif ($gametype eq 'BAM' && $tline =~ /^[0-9 ][0-9]/) {
                # Add hovering tooltip with team stength and seed rank.
                (my $team_id = substr($tline,0,3)) =~ s/\s*//g;
                $team_id = $secname . $team_id;
                my $pynames = {$team_id => [ @{$ppy->{$team_id}{'players'}} ]};
                my $str = '<span ' . tooltipteamjs($team_id, $pynames, $teamMP, $opt{'mpdisplay'}) . 
                  '>' . substr($tline,0,3) . '</span>';
                substr($tline,0,3) = $str;
              }
            }
            print OUT "$tline\n";
          }
        }
        
        elsif ($dvc eq 'iPhone') {
          # Rewrite lines in a more compact format.
          if ($tline =~ /^PAIRS IN STRAT/) {
            my $tline1 = $tline;
            while ( (my $pos = index($tline1, ',', $cs[$#cs]+1)) != -1 ) {
              push @cs, $pos;
            }
            shift(@cs);
            # Read next line and figure out column types.
            my $tline2 = shift(@textlines);
            for my $i (1..$#cs-1) {
              my $headertxt = substr($tline2, $cs[$i]+1, $cs[$i+1] - $cs[$i] - 1);
              (my $headername = $headertxt) =~ s/^\s+//; $headername =~ s/\s+$//;
              if ( ($headername eq 'Overall' || $headername eq 'Section') &&
                  length($headertxt) > 15) { $headername .= ' Rank'; } 
              push @ct, $headername;
              ## print "[$headertxt] [$headername]\n";
            }
            my $tline3 = shift(@textlines);
            my $tline4 = shift(@textlines);
            
            # This test relies on the single space (instead of multiple spaces) between
            # 'No' and 'Name'.
            if ($tline3 =~ /No Name/ ) { $ACBLscore760orLater = 1; }
            
            # If ACBLscore version is < 7.60, we are trimming 16 characters from these
            # header lines because player numbers will be removed by ACBLmerge.
            my $tline1m = substr($tline1, 0, 49);
            my $tline2m = substr($tline2, 0, 49);
            my $tline3m = 'No Name                   Name                   ';
            my $tline4m = substr($tline4, 0, 49);

            for my $i (0..$#cs-1) {
              my $fdlen = $cs[$i+1] - $cs[$i];
              # Only some fields will be altered.
              if ($ct[$i] eq 'Flt') {
                $tline1m .= ',-';
                $tline2m .= '| ';
                $tline3m .= '|F';
                $tline4m .= '|-';
              }
              elsif ($ct[$i] eq 'Overall Rank') {
                my($st, $ln) = ($cs[$i]+18, $fdlen-18);
                $tline1m .= ',-----------' . substr($tline1, $st, $ln);
                $tline2m .= '|  Overall  ' . substr($tline2, $st, $ln);
                $tline3m .= sprintf('| %s | %s | %s %s',
                substr($tline3, $cs[$i]+5,1), substr($tline3, $cs[$i]+11,1), 
                substr($tline3, $cs[$i]+17,1), substr($tline3, $st, $ln));
                $tline4m .= ' --- --- ---' . substr($tline4, $st, $ln);
              }
              elsif ($ct[$i] eq 'Section Rank') {
                my($st, $ln) = ($cs[$i]+18, $fdlen-18);
                $tline1m .= ',-----------' . substr($tline1, $st, $ln);
                $tline2m .= '|  Section     ' . substr($tline2, $st+3, $ln-3);
                $tline3m .= sprintf('| %s | %s | %s %s',
                substr($tline3, $cs[$i]+5,1), substr($tline3, $cs[$i]+11,1), 
                substr($tline3, $cs[$i]+17,1), substr($tline3, $st, $ln));
                $tline4m .= ' --- --- ---' . substr($tline4, $st, $ln);           
              }
              else {
                # No change to column.
                my $st = $cs[$i];
                $tline1m .= substr($tline1, $st, $fdlen);
                $tline2m .= substr($tline2, $st, $fdlen);
                $tline3m .= substr($tline3, $st, $fdlen);
                $tline4m .= substr($tline4, $st, $fdlen);
              }
            }
     
            $tline1m .= ','; $tline2m .= '|'; $tline3m .= '|';
            print OUT join("\n", ($tline1m, $tline2m, $tline3m, $tline4m));
            if ( $ACBLscore760orLater ) { print OUT "\n"; }
          }
          elsif ($tline =~ /^[0-9 ][0-9]/) {
            # Sometimes the ACBLscore output takes three lines / pair instead
            # of the usual two. This seems to happen when there are extra field(s)
            # like Qualifiers whose presence would cause the total line length
            # to exceed some value (probably the maximum width of the dot matrix
            # printers that the ACBL uses in tournaments). In this case the player
            # names and the first line and the rest of the information is on the
            # second line so that a long player name does not overlap the other
            # information.
            $inPairLines = 1;
            
            my ($pnum1, $pnum2);
            if ( ! $ACBLscore760orLater ) {
              $pnum1 = substr($tline, 3, 7);
              $pnum2 = substr($tline, 35, 7);
            }
            # Start with pair number and player names.
            my $tlinem = substr($tline, 0, 3);
            
            # Insert hyperlink for pair's recap sheet.
            # For example:  <a href="javascript:recap('I8N')">8</a>
            (my $pair_num = substr($tline,0,2)) =~ s/ //;             
            my $pair_id = $secname . $pair_num . substr($secdir,0,1);
            my $hlink = '<a href="javascript:recap(\'' . $pair_id . '\')">' .
              $pair_num . '</a>';
            if ($pair_num < 10) { $hlink = ' ' . $hlink; }
            substr($tlinem,0,2) = $hlink;
            
            # Copy player names and add masterpoint / faces tooltip if desired.
            my @ixlist;
            if ( $ACBLscore760orLater ) { @ixlist = (3, 26); } else { @ixlist = (11, 42); }
            for my $ix (@ixlist) {
              if ($opt{'mpdisplay'} || $opt{'showfaces'}) {
                # Add hovering JavaScript for tooltip to player names.
                (my $playerName = substr($tline,$ix,22)) =~ s/\s+$//;
                my $tooltip = '';
                if ($opt{'mpdisplay'}) {
                  my $mp = $pnn->{$playerName} ? $pmp->{$pnn->{$playerName}} : undef;
                  if (defined $mp) {
                    $tooltip = 'Has ~' . approxMP($mp) . " masterpoints as of $db_mmm $db_year";
                  }
                }
                my $str = '<span ' . tooltipjs($tooltip, $pnn->{$playerName}, $playerName) . '>' .
                  $playerName . '</span>' . ' ' x (23-length($playerName));
                $tlinem .= $str;  
              }
              else {
                $tlinem .= substr($tline, $ix, 23);
              }
            }      
            
            for my $i (0..$#cs-1) {
              my $fdlen = $cs[$i+1] - $cs[$i];
              if ($ct[$i] eq 'Flt') {
                $tlinem .= substr($tline,$cs[$i]+1,2);
              }
              elsif ($ct[$i] eq 'Overall Rank') {
                # The original rank fields are 5 characters (+ a space to
                # separating them. This accomodates ties in ranks 10 or higher,
                # e.g. 12/13. Compressing to three columns does not handle this
                # specific case well, but every other case should be okay.
                for my $j (0..2) { $tlinem .= substr($tline, $cs[$i]+$j*6,4); }
                $tlinem .= substr($tline, $cs[$i] + 18, $fdlen - 18);       
              }
              elsif ($ct[$i] eq 'Section Rank') {
                for my $j (0..2) { $tlinem .= substr($tline, $cs[$i]+$j*6+2,4); }
                $tlinem .= substr($tline, $cs[$i] + 18, $fdlen - 18);
              }
              elsif ($ct[$i] eq 'Qualifiers') {
                $tlinem .= substr($tline, $cs[$i], $fdlen);
              }
              else {
                # +1 here because ACBLscore's output does not line up correctly!
                # (for Score, Pct, and Final Awards)
                $tlinem .= substr($tline, $cs[$i]+1, $fdlen);
              }
              
            }
              
            print OUT $tlinem, "\n";
          }
          
          elsif ($tline =~ /^\s*Totals/) {
            $inPairLines = 0;
            my @fd = split /\s+/, $tline;
            print OUT "\n" if $dvc eq 'iPhone';
            print OUT ' ' x (74-length($fd[2])), $fd[1], ' ', $fd[2], "\n"  
          }
          elsif ($dvc ne 'iPhone' || !$inPairLines) {
            # Blow off home cities and and subsequent blank line if present after a pair in
            # iPhone customized output for compactness; Otherwise output line, escaping HTML
            # ampersand entity for clean HTML.
            $tline =~ s/>/&gt;/g;
            print OUT "$tline\n";              
          }
        }
        # End of iPhone device handling.
        
        else { die "Unhandled target device: $dvc. Check code."; }
      }
      print OUT "\n";
      $writtenOneSection = 1;
    }
  }

  print OUT '</pre>',  "\n";
  
  # Allow boards (+analysis) and/or board results to be hidden on iPhone output.
  if ($dvc eq 'iPhone') {
    print OUT << 'DONE';
<form action="#">
<p><span style="font-size: 180%">
<label for="resultsCB">Show boards &amp; analysis. </label>
<input id="boardCB" name="boardCB" type="checkbox" checked="checked" value="1"
  onclick="javascript:showhideClass('boardCB', 'board_analysis')"><br>
<label for="resultsCB">Show board results. </label>
<input id="resultsCB" name="resultsCB" type="checkbox" checked="checked" value="1"
  onclick="javascript:showhideClass('resultsCB', 'results_iphone')">
</span></p>
</form>

DONE
  }
      
  # Start table where first column holds hand and assorted annotations and
  # second column holds results.
  print OUT '<table id="main_table">', "\n";
  print OUT '<caption style="display: none">Hands and Results</caption>', "\n";

  foreach my $bnum (sort {$a <=> $b} keys %$br) {
    my ($dealer, $vul) = dealerVul($bnum);
    
    my @textlines = @{$br->{$bnum}};
    my @results;
    {
      # Allocate some variables once for better performance (but keep local).
      my (%sortkey, $mp_ns, $contract_sort, $denom_sort, $lead_sort);
      my ($section, $pair, $id, $contract, $level, $lead, $lcard);
      if ( !$bwsHasConts && !$bwsHasLeads ) {
        # Simple case of just sorting by N-S matchpoint scores
        foreach my $tline (@textlines) {
          $mp_ns = substr($tline, 12, 7);
          push @results, $tline;
          $sortkey{$tline} = $mp_ns;
        }
        @results = sort { $sortkey{$b} <=> $sortkey{$a} } @results;
      }
      else {
        # Include secondary sort on contract (high to low denomination)
        # and seat (N,S) (W,E) and possibly a tertiary sort on the opening
        # lead (high to low suits) and rank (high to low).
        foreach my $tline (@textlines) {
          $mp_ns = substr($tline, 12, 7);
          ($section, $pair) = substr($tline,27,4) =~ /([A-Z]*)(\d+)/;
          $section = $singleSection if !$section;
          $id = exists $bsc->{$section} ? $bsc->{$section}->{'ID'} : 0;
          $contract = $bws->{$id}{$bnum}{$pair}{'Contract'};
          if (! defined $contract || $contract eq '' || $contract eq 'PASS') {
            $contract_sort = '';
          }
          else {
            $level = substr($contract,0,1);
            ## print "contract: [$contract]\n"; ##
            $denom_sort = substr($contract,2,1);
            # Denominations are conveniently alphabetical (C, D, H, S) except
            # for NT. Fix this.
            $denom_sort = 'Z' if $denom_sort eq 'N';
            $contract_sort = $denom_sort . $level . $bws->{$id}{$bnum}{$pair}{'NS/EW'};
          }
          $lead = $bws->{$id}{$bnum}{$pair}{'LeadCard'};
          if (!defined $lead || $lead eq '') { $lead_sort = ''; }
          else {
            $lcard = substr($lead,1,1);
            # Correctly order leads of ten, jack, queen, king, and ace;
            $lcard =~ tr/1JQKA/ABCDE/;
            $lead_sort = substr($lead,0,1) . $lcard;    
          }
          push @results, $tline;
          $sortkey{$tline} = [$mp_ns, $contract_sort, $lead_sort];
        }
        @results = sort {
          $sortkey{$b}[0] <=> $sortkey{$a}[0] || 
          $sortkey{$b}[1] cmp $sortkey{$a}[1] ||
          $sortkey{$b}[2] cmp $sortkey{$a}[2]
        } @results;
      }
    }

    print OUT '<tr>', "\n";

    # Note: HTML standard requires id value to begin with a letter, hence
    # 'board+results#', rather than '#'.
    print OUT '<td class="board_analysis" id="board_results', $bnum, '">', "\n";

    # Dump board
    print OUT '  <table class="board" id="board', $bnum, '">', "\n";

    if (!defined $hd{$bnum}) {
      # Hand information is missing. For example, the 2009-04-09 Senior
      # pairs at the Pacific Southwest Regional used boards 37 and 38.
      
      print OUT '  <tr><td>', "\n";
      print OUT '    <table class="board_top"><tr>', "\n";
      print OUT '      <td class="boardnum">', $bnum, '</td>', "\n";
      print OUT '      <td class="dlrvul">', '<span class="nowrap">Dlr: ', $dealer, '</span><br>',
                         '<span class="nowrap">Vul: ', $vul, '</span>', "</td>\n";
      print OUT '    </tr></table>', "\n";
      print OUT '  </td></tr>', "\n";
      print OUT '  <tr><td>No hand record</td></tr>', "\n";
      print OUT '  </table>', "\n";
      print OUT '</td>', "\n";

      if ($dvc eq 'iPhone') { print OUT '</tr>', "\n"; }
      dumpHTMLresults($bnum, \@results, $dvc, $bsc, $bws, $bwsHasConts, $bwsHasLeads, $singleSection);
      next;
    }

    # Dump board (top row)
    print OUT '  <tr><td>', "\n";
    print OUT '    <table class="board_top"><tr>', "\n";
    print OUT '      <td class="boardnum">', $bnum, '</td>', "\n";
    tdhand($hd{$bnum}, 'north');
    print OUT '      <td class="dlrvul">', '<span class="nowrap">Dlr: ', $dealer, '</span><br>',
                       '<span class="nowrap">Vul: ', $vul, '</span>', "</td>\n";    
    print OUT '    </tr></table>', "\n";
    print OUT '  </td></tr>', "\n";

    # Dump board (middle row)
    print OUT '  <tr><td>', "\n";
    print OUT '    <table class="board_middle"><tr>', "\n";
    tdhand($hd{$bnum}, 'west');
    tdhand($hd{$bnum}, 'east');
    print OUT '    </tr></table>', "\n";
    print OUT '  </td></tr>', "\n";

    # Dump board (bottom row)
    print OUT '  <tr><td>', "\n";
    print OUT '    <table class="board_bottom"><tr>', "\n";
    tdhand($hd{$bnum}, 'south');
    print OUT '    </tr></table>', "\n";
    print OUT '  </td></tr>', "\n";

    # Dump board finish.
    print OUT '  </table>', "\n";

    # Dump HCP and makeable contracts (if double dummy analysis requested).
    my $hcp = hcphand($hd{$bnum});
    print OUT '  <table class="hcp_makeable"><tr>', "\n";
    print OUT '    <td>', "\n";
    print OUT '      <table class="HCP">', "\n";
    print OUT "         <tr><td></td><td>$hcp->{'north'}</td><td></td></tr>\n";
    print OUT "         <tr><td>$hcp->{'west'}</td><td></td><td>$hcp->{'east'}</td></tr>\n";
    print OUT "         <tr><td></td><td>$hcp->{'south'}</td><td></td></tr>\n";
    print OUT '      </table>', "\n";
    print OUT '    </td>', "\n";
    if ( $opt{'dd'} ) { ddmakeshand($hd{$bnum}); }
    print OUT '  </tr></table>', "\n";

    print OUT '  <table class="lott_par_copyaids"><tr>', "\n";
    if ( $opt{'dd'} ) {
      my $lottadj = $hd{$bnum}{'totalTricks'} - $hd{$bnum}{'totalTrumps'};
      print OUT '    <td>', 'LoTT: ', $hd{$bnum}{'totalTricks'}, ' - ', $hd{$bnum}{'totalTrumps'},
      ' = ', ($lottadj > 0 ? '+' : ''), $lottadj, '<br>';
      print OUT $hd{$bnum}{'parHTML'}, '</td>', "\n";
    }
    my $jstxt = sprintf "javascript:c1('%d','%s','%s','%s','%s')", $bnum,
      $hd{$bnum}{'west'}, $hd{$bnum}{'north'}, $hd{$bnum}{'east'},
      $hd{$bnum}{'south'};
    print OUT '    <td><input type="button" value="C" onclick="',
      $jstxt, '"></td>', "\n";
    print OUT '  </tr></table>', "\n";

    # End of left side (top half for iPhone)
    print OUT '</td>', "\n";
    
    if ($dvc eq 'iPhone') { print OUT '</tr>', "\n"; }
    dumpHTMLresults($bnum, \@results, $dvc, $bsc, $bws, $bwsHasConts, $bwsHasLeads, $singleSection);
  }
  print OUT '</table>', "\n";
  print OUT '</div>';
  
  # Insert optional user supplied content.
  if ( $opt{'ieb_fname'} ) { insertFile($opt{'ieb_fname'}) }; 
  print OUT '</body>',  "\n";
  print OUT '</html>',  "\n";

  close(FILE);
  close(OUT);
}

sub dumpHTMLwinners {
  # Creates a table of masterpoint winners in the HTML output.
  if (scalar(@_) != 3) { die "function requires 2 arguments."; }
  my ($dvc, $evt, $ppy) = @_;
  
  # Percentage is not provided for IMP Pairs because it is not meaningful.
  my $hasPct = $evt->{'hasPct'};
  # Count masterpoint winners and see if it is reasonable to abbreviate
  # 'Masterpoint' header as 'MP'.
  my $nWinners = 0; my $hasAwardReason; my $abbrevMP = 1;
  foreach my $pair_id (keys %$ppy) {
    $nWinners++ if $ppy->{$pair_id}{'Awards'} ne '';
    $abbrevMP = 0 if length($ppy->{$pair_id}{'Awards'}) > 5;
    $hasAwardReason = 1 if defined $ppy->{$pair_id}{'Reason'};
  }
  my @pair_ids;
  if ($hasPct) {
    @pair_ids = sort {$ppy->{$b}{'Pct'} <=> $ppy->{$a}{'Pct'}} keys %$ppy;
  }
  else {
    @pair_ids = sort {$ppy->{$b}{'Score'} <=> $ppy->{$a}{'Score'}} keys %$ppy;
  }

  my $twoCol = $dvc eq 'default' && $nWinners > 10;
  my ($strat, $rankidx, $rank, $rank2, $rankcol, $rankstr, $ix, $sf, $name1, $name2, $awards);

  my $captionHTML = '<caption class="winnersCaption">' .
    '<span class="stars">&#9733; &#9733; &#9733;&nbsp;&nbsp;</span>' . 
    'Masterpoint Winners&nbsp;&nbsp;<span class="stars">&#9733; &#9733; &#9733;</span></caption>';
  my $notFinalText = <<'END';
This is a multi-session event. These masterpoint awards are not final. You will receive
at least the award shown. For example, if the award for your overall performance in a two
session event is greater than your current award, you will receive that final award instead
of (not in addition to) the award shown here.
END
  my $FinalMultiSessionText = <<'END';
The percentage shown here is for this session only. The final masterpoint award shown
is based on performance in all sessions and is the better of your multi-session overall
award or the sum of your individual session award(s).
END

  print OUT "\n";
  print OUT '<table class="winnersWrapper">', "\n", $captionHTML, "\n", '<tr>', "\n" if ($twoCol);
  
  my $pair_ix = 0; my $nWinnersInCol = 0; my $reason;
  my $nWinnersPerCol = $twoCol ? int($nWinners / 2) + $nWinners % 2 : $nWinners;
  for (my $i=0; $i<($twoCol ? 2 : 1); $i++) {
    my $class = $twoCol ? 'winners2col' : 'winners1col';
    print OUT '<td>', "\n" if $twoCol;
    print OUT '<table class="winners ', $class, '">', "\n";
    print OUT $captionHTML, "\n" if !$twoCol;
    print OUT '  <thead><tr> <td>Partnership</td> ',
      '<td class="center">', $hasPct ? 'Pct' : 'Score', '</td> ', 
      $hasAwardReason ? '<td class="right">Rank</td> ' : '',
      '<td', $abbrevMP ? ' class="center">MP' : '>Masterpoints', '</td> ', '</tr></thead>', "\n";
    print OUT '  <tbody>', "\n";
    foreach my $pair_id ( @pair_ids[$pair_ix..$#pair_ids] ) {
      $pair_ix++;
      if ($ppy->{$pair_id}{'Awards'} eq '') { next; }
      if ($hasAwardReason) {
        $reason = $ppy->{$pair_id}{'Reason'};
        $reason = 'S' . $reason if $reason !~ /^[SO]/;
        if ($evt->{'nstrats'} == 1) {
          $rankcol = 'Rnk1' . $reason;
        }
        else {
          $rankidx = index($evt->{'strats'}, substr($reason, -1)) + 1;
          $rankcol = 'Rnk' . $rankidx . substr($reason, 0, 1);
        }
        $rank = $ppy->{$pair_id}{$rankcol};
        # Deal with ties, e.g. 3/4 should be written "3/4th" rather than "3/4rd"
        $ix = index($rank, '/');
        if ($ix == -1) { $rank2 = $rank; } else { $rank2 = substr($rank, $ix+1); }
        $sf = $rank2 == 1 ? 'st' : $rank2 == 2 ? 'nd' : $rank2 == 3 ? 'rd' : 'th';
        $rankstr = $rank . $sf . ' ' . $ppy->{$pair_id}{'Reason'};
      }
      
      my $name1 = $ppy->{$pair_id}{'player1'};
      my $name2 = $ppy->{$pair_id}{'player2'};
      my @strs;
      foreach my $playerName ($name1, $name2) {
        my $str = $playerName;
        if ( $opt{'cgip'} ) {
          my $url = $opt{'cgip'} . ( defined $pnn->{$playerName} ? 
            '?pnum=' . $pnn->{$playerName} : '?pname=' . uri_escape($playerName) );
          $str = '<a href="' . $url . '" class="hoverlink">' . $playerName . '</a>';
        }
        if ($opt{'mpdisplay'} || $opt{'showfaces'}) {
          my $tooltip = '';
          if ($opt{'mpdisplay'}) {
            my $mp = $pnn->{$playerName} ? $pmp->{$pnn->{$playerName}} : undef;
            if (defined $mp) {
              $tooltip = 'Has ~' . approxMP($mp) . " masterpoints as of $db_mmm $db_year";
            }
          }
          $str = '<span ' . tooltipjs($tooltip, $pnn->{$playerName}, $playerName) . '>' .
            $str . '</span>';
        }
        push @strs, $str;
      }
      
      print OUT '  <tr> <td>', ($name1 lt $name2) ? "$strs[0] - $strs[1]" : "$strs[1] - $strs[0]", '</td> ';
      print OUT '<td class="right">', 
        sprintf('%.2f', $ppy->{$pair_id}{$hasPct ? 'Pct' : 'Score'}), '</td> ';
      print OUT '<td class="right">', $rankstr, '</td> ' if ($hasAwardReason);
      ($awards = $ppy->{$pair_id}{'Awards'}) =~ s/,/, /g;
      print OUT '<td>', $awards, '</td> </tr>', "\n";
      $nWinnersInCol++;
      if ($nWinnersInCol == $nWinnersPerCol) { last; }
    }
    print OUT '  </tbody>', "\n";
    print OUT '</table>', "\n";
    print OUT '</td>', "\n" if $twoCol;
  }
  
  if ($twoCol) {
    if ($evt->{'finalAwards'} && !$evt->{'isMultiSession'}) { print OUT '</tr>'; }
    elsif (! $evt->{'finalAwards'}) {
      print OUT '</tr>', "\n", '<tr><td colspan="2">', '<p class="winnersNotFinal">', "\n",
        $notFinalText, '</p></td></tr>', "\n";
    }
    else {
      print OUT '</tr>', "\n", '<tr><td colspan="2">', '<p class="multiSessionFinal">', "\n",
        $FinalMultiSessionText, '</p></td></tr>', "\n";      
    }
    if ($opt{'mssurl'}) {
      print OUT '<tr><td colspan="2"><p class="mssurl2"><a href="', $opt{'mssurl'}, '">',
        'View overall rankings for all sections and/or sessions', '</a></p></td></tr>';
    }    
    print OUT '</table>', "\n";
  }
  else {
    if (! $evt->{'finalAwards'}) {
      print OUT '<p class="winnersNotFinal">', "\n", $notFinalText, '</p>', "\n";    
    }
    if ($opt{'mssurl'}) {
      print OUT '<p class="mssurl1"><a href="', $opt{'mssurl'}, '">',
        'View overall rankings for all sections and/or sessions', '</a></p>', "\n";
    }
  }
  
  print OUT "\n";
}

sub dumpHTMLresults {
  # Dumps the results for one hand.
  if (scalar(@_) != 8) { die "function requires 8 arguments."; }  
  my ($bnum, $presults, $dvc, $bsc, $bws, $bwsHasConts, $bwsHasLeads, $singleSection) = @_;

  if ($dvc eq 'default') {
    # Dump results as plaintext.
    print OUT '<td class="results" id="results', $bnum, '">', "\n";
    print OUT '<pre>', "\n";
    my $theader = '  N-S   E-W    N-S    E-W';
    if ($bwsHasConts) { $theader .= '   Contract'; }
    if ($bwsHasLeads) { $theader .= '  Ld'; }
    print OUT "$theader\n";
    my ($section, $pair, $id);
    foreach my $result (@$presults) {
      ($section, $pair) = substr($result,27,4) =~ /([A-Z]*)(\d+)/;
      $section = $singleSection if !$section;
      if (exists $bsc->{$section}) { $id = $bsc->{$section}->{'ID'}; } else { $id = 0; }
        
      if ($bwsHasLeads) {
        substr($result,27,0) = leadHTML($bws->{$id}{$bnum}{$pair}{'LeadCard'}, 
          $bws->{$id}{$bnum}{$pair}{'LeadCheck'}) . '  ';
      }
      if ($bwsHasConts) {
        substr($result,27,0) = ' ' . contractHTML($bws->{$id}{$bnum}{$pair}{'Contract'}, 
          $bws->{$id}{$bnum}{$pair}{'Result'}, $bws->{$id}{$bnum}{$pair}{'NS/EW'} );
      }
      print OUT "$result\n";
    };
    print OUT '</pre>', "\n", '</td>', "\n";
    print OUT '</tr>', "\n";
    print OUT "\n";
  }
  elsif ($dvc eq 'iPhone') {
    # Reformat results to fit in an HTML table. This allows column alignment
    # to be preserved while using a proportional in order to make the best use
    # of the small iPhone display screen.
    
    my $trow = '<td class="center">N-S</td><td class="center">E-W</td>' .
		  '<td class="center">N-S</td><td class="center">E-W</td>';
		$trow .= '<td class="left">Contract</td>' if $bwsHasConts;
		$trow .= '<td class="left">Ld</td>' if $bwsHasLeads;
		$trow .= '<td class="bn">Board ' . $bnum . '</td>';
    
    print OUT <<"END";
<tr><td>
  <table class="results_iphone">
    <thead>
      <tr>$trow</tr>
    </thead>
    <tbody>
END
    my ($section, $pair, $id, $contractHTML, $leadHTML);
    foreach my $tline (@$presults) {
      my $scoreline = substr($tline, 1, 10);
      # Parse fields and strip whitespace.
      (my $mp_ns = substr($tline, 12, 7)) =~ s/\s+//;
      (my $mp_ew = substr($tline, 19, 7)) =~ s/\s+//;
      (my $pairnames = substr($tline, 27, 48)) =~ s/\s+$//;
      my ($ns_score, $ew_score);
      # Scoreline has some special cases such as PASS and the AVE- and AVE+
      # adjusted scores.
      if ($scoreline =~ /PASS/) {
        $ns_score = 'PASS'; $ew_score = 'PASS';
      }
      else {
        ($ns_score = substr($tline, 1, 4)) =~ s/\s+//;
        ($ew_score = substr($tline, 7, 4)) =~ s/\s+//;
      }
      if ($scoreline =~ /PASS/ || $scoreline =~ /AVE/) {
        # Center these special cases.
        print OUT '<tr><td class="center">', $ns_score,
          '</td><td class="center">', $ew_score, '</td>';        
      }
      else {
        # Right align numerical scores.
        print OUT '<tr><td class="right">', $ns_score,
          '</td><td class="right">', $ew_score, '</td>';
      }
      print OUT '<td class="right">', $mp_ns,
        '</td><td class="right">', $mp_ew, "</td>";
        
      ($section, $pair) = substr($tline,27,4) =~ /([A-Z]*)(\d+)/;
      $section = $singleSection if !$section;
      if (exists $bsc->{$section}) { $id = $bsc->{$section}->{'ID'}; } else { $id = 0; }
        
      if ($bwsHasConts) {
        $contractHTML = contractHTML($bws->{$id}{$bnum}{$pair}{'Contract'}, 
          $bws->{$id}{$bnum}{$pair}{'Result'}, $bws->{$id}{$bnum}{$pair}{'NS/EW'} );
        $contractHTML =~ s/\s+$//;
        print OUT '<td>', $contractHTML, '</td>'  
      }
      if ($bwsHasLeads) {
        $leadHTML = leadHTML($bws->{$id}{$bnum}{$pair}{'LeadCard'}, 
          $bws->{$id}{$bnum}{$pair}{'LeadCheck'});
        print OUT '<td>', $leadHTML, '</td>'  
      }
      
      print OUT "<td>$pairnames</td></tr>\n";        
    }
		print OUT <<'END';
	  </tbody>
  </table>
</td></tr>
END
  }
  else {
    die "Unsupported device: $dvc. Check code.";
  }
}

sub dumpHTMLteams {
  # Create HTML output for a team game.
  if (scalar(@_) != 10) { die "function requires 9 arguments."; }  
  my ($resfname, $outfname, $evt, $pnn, $pmp, $fsdata, $db_year, $db_mmm,
    $pyteams, $teamMP) = @_;
  
  if ($outfname) {
    if (!open(OUT, '>', $outfname)) {
      print STDERR "Unable to open/write: $outfname"; exit($EXIT_FILE_ERR);
    }
  }
  else {
    open(OUT, ">-");
  }
  if ( $opt{'crlf'} ) { binmode(OUT, ':crlf'); }
  
  # Write start of HTML document, i.e. <!DOCTYPE> and <meta> tags
  HTMLheadstart();

  print OUT "<title>";
  if ($opt{'title'}) {
    print OUT $opt{'title'};
  }
  else {
    my @fd = split /\s+/, $evt->{'datestr'};
    # Chop month down to first three characters. This makes it more likely
    # that the day will also be visible if the user has many tabs open.
    my $datestr = join(' ', (substr($fd[0],0,3), $fd[1], $fd[2]));
    # Downcase all but first letter of each word in event name
    @fd = split /\s+/, $evt->{'event'};
    foreach my $fd (@fd) { substr($fd,1) =~ tr/A-Z/a-z/; }
    print OUT "$datestr ", join(' ', @fd);
  }
  print OUT "</title>\n";

  # CSS needed for teams.
  CSSheader('teams');

  # Javascript needed for teams.
  JSheader('teams');
  
  # Insert optional user supplied content.
  if ( $opt{'ih_fname'} ) { insertFile($opt{'ih_fname'}); } 
  print OUT "</head>\n\n";
  
  print OUT '<body>', "\n";
  # Insert optional user supplied content.
  if ( $opt{'isb_fname'} ) { insertFile($opt{'isb_fname'}) };

  print OUT '<div id="ACBLmerge">', "\n";
  print OUT '<div id="topinfo">', "\n";
  if (! $opt{'nohurl'}) {
    print OUT '<a class="nolinkunderline" href="',
    $opt{'hurl'} ? $opt{'hurl'} : $DEFAULT_HELP_URL, 
    '"><span class="help"><strong>?</strong></span></a>&nbsp;<a href="',
    $opt{'hurl'} ? $opt{'hurl'} : $DEFAULT_HELP_URL,
    '">Explanation of report features</a>&nbsp;&nbsp;', "\n";
  }
    
  # Write hyperlinks to various files (original txt, PBN, GIB, and PDF as appropriate)
  filelinkHTML();

  # Field strength colorbar
  fsHTML($fsdata) if defined $fsdata;
  
  # Checkbox for showing faces.
  if ($opt{'showfaces'}) {
    # value="dummy" satisfies overly picky HTML syntax checkers.
    print OUT <<"DONE";
<form action="#">
<input id="showfacesCB" name="showfacesCB" type="checkbox" checked="checked" value="dummy">
<label for="showfacesCB">Show faces.</label>
</form>

DONE
  }

  # End of <div id=""topinfo">"
  print OUT '</div>', "\n";

  print OUT '<pre>',  "\n";

  my $have_player_nums = 0;
  my ($fline, @plines);
  open(FILE, '<:crlf', $resfname) or return("  Unable to open/read: $resfname");
  while ($fline = <FILE>) {
    chomp($fline);
    # Ignore any of the minimal HTML tags that ACBLscore writes if the input file
    # is an HTML report. Also ignore any pseudotags like <!A> (ACBLscore might only
    # write them for pairs results, but assume the worst.)
    if ($fline =~ /^<html>\s*<pre>$/ || $fline =~ /^<\/pre>\s*<\/html>$/ ||
        $fline =~ /^<![A-Z]+\d*>/ ) { next; }
    # Escape HTML ampersand entity for clean HTML.
    $fline =~ s/>/&gt;/g;
    print OUT $fline, "\n";
    if ($fline =~ /\s*No Name\s+/) { last; }
    if ($fline =~ /\s*No\s+Name\s+/) { $have_player_nums = 1; last; }
  }
  
  # Copy ---- line.
  $fline = <FILE>; chomp($fline); print OUT $fline, "\n";
  
  ## print "hasCities: ", $evt->{'hasCities'}, "\n";
  my $pyname;
  my $teamlinenum = 0;
  my @namepos = $have_player_nums ? (52, 12) : (36, 4);
  $namepos[0] -= 9 if ! $evt->{'final'};
  
  while ($fline = <FILE>) {
    chomp($fline);
    if ($fline =~ /^\s*TOTALS\s+/) { print OUT $fline, "\n"; last; }
    if ($fline =~ /^- - - - /) { $teamlinenum = 0; }    
    else {
      $teamlinenum++;
      if ( (!$evt->{'hasCities'} || $teamlinenum % 2 == 1) &&
           ($opt{'cgip'} || $opt{'mpdisplay'} || $opt{'showfaces'}) ) {
        # Add hovering JavaScript for tooltip to player names. Need to do it "backwards"
        # (player 2 before player 1) because we are modifying $fline as we go.
        my ($url, $mp, $tooltip, $str);
        for my $ix (@namepos) {
          (my $playerName = substr($fline,$ix,22)) =~ s/\s+$//;
          # A five person team will have an empty slot.
          if ($playerName eq '') { next; }
          my $str = $playerName;
          if ( $opt{'cgip'} ) {
            my $url = $opt{'cgip'} . ( defined $pnn->{$playerName} ? 
              '?pnum=' . $pnn->{$playerName} : '?pname=' . uri_escape($playerName) );
            $str = '<a href="' . $url . '" class="hoverlink">' . $playerName . '</a>';
          }
          if ($opt{'mpdisplay'} || $opt{'showfaces'}) {
            $tooltip = '';
            if ($opt{'mpdisplay'}) {
              $mp = $pmp->{$pnn->{$playerName}};
              if (defined $mp) {
                $tooltip = 'Has ~' . approxMP($mp) . " masterpoints as of $db_mmm $db_year";
              }
            }
            $str = '<span ' . tooltipjs($tooltip, $pnn->{$playerName}, $playerName) . '>' .
              $str . '</span>';
          }
          substr($fline,$ix,22) = $str . ' ' x (22-length($playerName));  
        }
        if ( substr($fline,0,3) =~ /\s*\d+\s*/ ) {
          # Add hovering tooltip to team number.
          (my $teamnum = substr($fline,0,3)) =~ s/\s*//g;
          $str = '<span ' . tooltipteamjs($teamnum, $pyteams, $teamMP, $opt{'mpdisplay'}) . 
            '>' . substr($fline,0,3) . '</span>';
          substr($fline,0,3) = $str;            
        }
      }
    }
    print OUT $fline, "\n";
  }
  
  my ($emptyline, $lastempty, $versusTeamsLine);
  while ($fline = <FILE>) {
    chomp($fline);
    if ($fline =~ /^<html>\s*<pre>$/ || $fline =~ /^<\/pre>\s*<\/html>$/ ||
        $fline =~ /^<![A-Z]+\d*>/ ) { next; }
    # Wipe out trailing empty lines.
    $emptyline = $fline =~ /^\s*$/;
    if ($emptyline && $lastempty) { next; }
    
    $versusTeamsLine = ($fline =~ /^\s*\d+>/);
    $fline =~ s/>/&gt;/g;
    
    if ($versusTeamsLine) {
      # Add hovering tooltip for opposing teams, i.e. over 'v14' etc.
      my @locs; my $ix = 0; my $teamnum; my $str;
      while ( ($ix = index($fline, 'v', $ix)) != -1 ) { push @locs, $ix; $ix++; }
      foreach $ix (reverse @locs) {
        ($teamnum) = substr($fline,$ix+1) =~ /^(\d+)/;
        $str = '<span ' . tooltipteamjs($teamnum, $pyteams, $teamMP, $opt{'mpdisplay'}) . 
          '>' . substr($fline,$ix,1+length($teamnum)) . '</span>';
        substr($fline,$ix,1+length($teamnum)) = $str;       
      }
      # Add hovering tooltip for team (at start of row). Replace 8 characters because we
      # have previously converted the > after the team number to &gt;
      if ( substr($fline,0,4) =~ /^\s*\d+\s*/ ) {
        ($teamnum = substr($fline,0,4)) =~ s/\s*//g;
    
        $str = '<span ' . tooltipteamjs($teamnum, $pyteams, $teamMP, $opt{'mpdisplay'}) . 
                '>' . substr($fline,0,8) . '</span>';
        substr($fline,0,8) = $str;       
      }      
    }
    
    print OUT $fline, "\n";
    $lastempty = $emptyline;
  }
  close(FILE);
  
  print OUT '</pre>', "\n";
  print OUT '</div>', "\n";
  
  # Insert optional user supplied content.
  if ( $opt{'ieb_fname'} ) { insertFile($opt{'ieb_fname'}) }; 
  print OUT '</body>',  "\n";
  print OUT '</html>',  "\n";

  close(OUT);
  
  return('');
}

sub filelinkHTML {
  # Write out links to various file at top of HTML output.
  if (defined $opt{'txturl'}) {
    print OUT '<a class="diminishedLink" href="', $opt{'txturl'},
      '">View original ACBLscore output</a>';    
  }
  elsif ($opt{'txtfname'} || $opt{'resfname'} =~ /\.txt$/i ) {
    my ($bname);
    if ($opt{'txtfname'}) { ($bname = $opt{'txtfname'}) =~ s/.*[\\\/]//; }      
    else { ($bname = $opt{'resfname'}) =~ s/.*[\\\/]//; }
    print OUT '<a class="diminishedLink" href="', $bname,
      '">View original ACBLscore output</a>';
  }
  print OUT '<br>', "\n";
  
  my $PBNlink = $opt{'pbnfname'} || (defined $hformat && $hformat eq 'PBN') || defined $opt{'pbnurl'};
  my $GIBlink = $opt{'gibfname'} || (defined $hformat && $hformat eq 'GIB') || defined $opt{'giburl'};
  my $LINlink = $opt{'linfname'} || (defined $hformat && $hformat eq 'LIN') || defined $opt{'linurl'};
  my $PDFlink = $opt{'pdffname'};
  my @links;
  if ($PBNlink || $GIBlink || $LINlink || $PDFlink) {
    if ( $opt{'pbnurl'} ) {
      push @links, '<a href="' . $opt{'pbnurl'} . '">PBN</a>';
    }
    elsif ($opt{'pbnfname'} || $hformat eq 'PBN') {
      # Remove file path (if any)
      my $bname;
      if ($opt{'pbnfname'}) { ($bname = $opt{'pbnfname'}) =~ s/.*[\\\/]//; }      
      else {
        ($bname = $opt{'handfname'}) =~ s/.*[\\\/]//;
        $bname =~ s/\.[A-Za-z0-9]+$//;
        $bname .= '.pbn';   
      }
      push @links, '<a href="' . $bname . '">PBN</a>';
    }
    if ( $opt{'giburl'} ) {
      push @links, '<a href="' . $opt{'giburl'} . '">GIB</a>';
    }
    elsif ($opt{'gibfname'} || $hformat eq 'GIB') {
      my $bname;
      if ($opt{'gibfname'}) { ($bname = $opt{'gibfname'}) =~ s/.*[\\\/]//; }      
      else {
        ($bname = $opt{'handfname'}) =~ s/.*[\\\/]//;
        $bname =~ s/\.[A-Za-z0-9]+$//;
        $bname .= '.gib';
      }
      push @links, '<a href="' . $bname . '">GIB</a>',

    }
    if ( $opt{'linurl'} ) {
      push @links, '<a href="' . $opt{'giburl'} . '">LIN</a>';
    }
    elsif ($opt{'linfname'} || $hformat eq 'LIN') {
      my $bname;
      if ($opt{'linfname'}) { ($bname = $opt{'linfname'}) =~ s/.*[\\\/]//; }      
      else {
        ($bname = $opt{'handfname'}) =~ s/.*[\\\/]//;
        $bname =~ s/\.[A-Za-z0-9]+$//;
        $bname .= '.lin';
      }
      push @links, '<a href="' . $bname . '">LIN</a>',

    }
    if ($PDFlink) {
      my $isWindowsPath = $PDFlink =~ /^([A-Za-z]:|\\\\)/;
      if ($isWindowsPath) { $PDFlink =~ s/.*[\\\/]//; }
      push @links, '<a href="' . $PDFlink . '">PDF</a>',
    }
    print OUT 'Download hands in ', join(' or ', @links), ' format ', 
      '(Right click and choose &ldquo;Save Link As...&rdquo; ',
      'in Firefox or &ldquo;Save Target As...&rdquo; in IE)<br>', "\n";
  }
}

sub tdhand {
  # Print HTML for one seat.
  my ($hand, $seat) = @_;
  my @suits = split /\./, $hand->{$seat};
  my @suitentities = ('&spades;', '&hearts;', '&diams;', '&clubs;');

  my $indent = 6;
  print OUT ' ' x $indent, '<td class="', $seat, '">', "\n";
  if ($opt{'tablemarker'}  && $seat eq 'east') {
    print OUT ' ' x $indent, '<div class="eastwrapper">'. "\n";
    print OUT ' ' x $indent, '<div class="tablecloth"></div>', "\n";
  }
  for (my $i=0; $i<4; $i++) {
    print OUT ' ' x $indent;
    if ($i == 1) { print OUT '<span class="hs">'; }
    elsif ($i == 2) { print OUT '<span class="ds">'; }
    print OUT $suitentities[$i];
    if ($i == 1 || $i == 2) { print OUT '</span>'; }
    if ( !defined $suits[$i] || $suits[$i] eq '' ) { print OUT "-"; }
    else { print OUT $suits[$i]; }
    print OUT "<br>\n";
  }
  if ($opt{'tablemarker'} && $seat eq 'east') {
    print OUT ' ' x $indent, '</div>'. "\n";
  }  
  print OUT ' ' x $indent, '</td>', "\n";
}


sub leadCheck {
  # Check if each lead is from the correct seat (Bridgemates do not validate the opening
  # lead when it is entered.
  if (scalar(@_) != 4) { die "function requires 4 arguments."; }
  my ($sections, $phd, $bsc, $bws) = @_;

  my @seats = ('west', 'north', 'east', 'south');
  # Seat that should have the lead and seat opposite that seat if corresponding
  # seat in @seats is declarer.
  my @lseat = @seats[1..3,0];
  my @oseat = @seats[3,0..2];
  my ($id, %seatSuits, $lsuit, $lcard, $ixl, $ixd);

  # Only check leads for the section(s) we need.
  foreach my $section (sort keys %$sections) {
    if (exists $bsc->{$section}) { $id = $bsc->{$section}->{'ID'}; } else { next; }

    foreach my $bnum (sort {$a <=> $b} keys %{$bws->{$id}}) {
      my $hand = $phd->{$bnum};
      foreach my $seat (@seats) { $seatSuits{$seat} = [ split /\./, $hand->{$seat} ]; }
      my $bwb = $bws->{$id}{$bnum};
      my ($ctr, $lead, $declarer);
      foreach my $pair (keys %$bwb) {
        $ctr = $bws->{$id}{$bnum}{$pair}{'Contract'};
        if ($ctr eq 'PASS') { $bws->{$id}{$bnum}{$pair}{'LeadCheck'} = 'ok'; next; }
        $lead = $bwb->{$pair}{'LeadCard'};
        if ($lead) {
          $lsuit = substr($lead,0,1);
          $lcard = substr($lead,1);
          $lcard = 'T' if $lcard eq '10';
          $ixl = $lsuit eq 'S' ? 0 : $lsuit eq 'H' ? 1 : $lsuit eq 'D' ? 2 : 3;
          $declarer = $bws->{$id}{$bnum}{$pair}{'NS/EW'};
          $ixd = $declarer eq 'W' ? 0 : $declarer eq 'N' ? 1 : $declarer eq 'E' ? 2 : 3;
          if ( index($seatSuits{$lseat[$ixd]}[$ixl], $lcard) != -1 )  {
            $bws->{$id}{$bnum}{$pair}{'LeadCheck'} = 'ok';
          }
          elsif ( index($seatSuits{$oseat[$ixd]}[$ixl], $lcard) != -1 ) {
            $bws->{$id}{$bnum}{$pair}{'LeadCheck'} = 'opp';
          }
          else { $bws->{$id}{$bnum}{$pair}{'LeadCheck'} = 'wrong'; }
        }
        else { $bws->{$id}{$bnum}{$pair}{'LeadCheck'} = 'ok'; }
      }
    }
  }
  return $bws;
}

sub hcphand {
  # Calculate the number of high card points (HCP) in each seat for a board.
  my ($hand) = @_;
  my %hcp;
  foreach my $seat ('west', 'north', 'east', 'south') {
    my $cards = $hand->{$seat};
    my $hcp1 = 0;
    for (my $i=0; $i<length($cards); $i++) {
      if (substr($cards,$i,1) eq 'A') {$hcp1 += 4;}
      elsif (substr($cards,$i,1) eq 'K') {$hcp1 += 3;}
      elsif (substr($cards,$i,1) eq 'Q') {$hcp1 += 2;}
      elsif (substr($cards,$i,1) eq 'J') {$hcp1++;}
    }
    $hcp{$seat} = $hcp1;
  }
  return \%hcp;
}

sub leadHTML {
  # Converts lead, e.g. 'C9' to HTML.
  my ($lead, $leadCheck) = @_;
  return ' ' x 2 if !$lead;
  my $suit = substr($lead,0,1);
  my $card = substr($lead,1);
  $card = 'T' if $card eq '10';
  
  my $str;
  if ($suit eq 'S') { $str = '&spades;'; }
  elsif ($suit eq 'H') { $str = '<span class="hs">&hearts;</span>'; }
  elsif ($suit eq 'D') { $str = '<span class="ds">&diams;</span>'; }
  elsif ($suit eq 'C') { $str = '&clubs;'; }
  else {
    $str = '?';
    if ( !opt{'quiet'} ) {
      print STDERR "Unexpected lead suit designation: $suit (not C D H S).\n";
    }
  }
  
  $str .= $card;
  if ($leadCheck eq 'wrong') { $str = '<span class="badlead">' . $str . '</span>'; }
  elsif ($leadCheck eq 'opp') { $str = '<span class="opplead">' . $str . '</span>'; }
   
  return $str;
}

sub contractHTML {
  # Converts contract to HTML.
  my ($contract, $result, $seat) = @_;
  return ' ' x 10 if !$contract;
  return 'Pass Out  ' if $contract eq 'PASS';
  
  my $nchar = 0;
  substr($contract,1,1) = '';
  substr($contract,1,2) = 'N' if substr($contract,1,2) eq 'NT';
  if ($contract =~ s/ xx/**/) { $nchar += 2 };
  if ($contract =~ s/ x/*/) { $nchar += 1 };
  
  my $denom = substr($contract,1,1);
  if ($denom eq 'S') { substr($contract,1,1) = '&spades;'; }
  elsif ($denom  eq 'H') { substr($contract,1,1) = '<span class="hs">&hearts;</span>'; }
  elsif ($denom  eq 'D') { substr($contract,1,1) = '<span class="ds">&diams;</span>'; }
  elsif ($denom  eq 'C') { substr($contract,1,1) = '&clubs;'; }

  $contract .= ' ' . $seat . ' ';
  if ( $opt{'americanstyle'} ) {
    if ( substr($result,0,1) eq '-' ) {
      $contract .= $result; $nchar += length($result);      
    }
    else {
      my $tricks = substr($contract,0,1);
      $tricks += $result if ($result ne '='); $nchar++;
      $contract .= $tricks;
    }
  }
  else {
    if ($result ne '=') { $contract .= $result; $nchar += length($result); }
  }
  $contract .= ' ' x (5 - $nchar);
  
  return $contract;
}

sub fsHTML {
  # Display field strength color bar and field strength data.
  if (scalar(@_) != 1) { die "function requires 1 argument."; }
  my ($fsdata) = @_;
  
  # Number of masterpoints represented at left and right end of the bar.
  my $BAR_MIN = 1;
  my $BAR_MAX = 20000;
  
  # Colormap for the field strength bar.
  my @cm = ('#00008f', '#00009f', '#0000af', '#0000bf', '#0000cf', '#0000df', '#0000ef',
            '#0000ff', '#0010ff', '#0020ff', '#0030ff', '#0040ff', '#0050ff', '#0060ff',
            '#0070ff', '#0080ff', '#008fff', '#009fff', '#00afff', '#00bfff', '#00cfff',
            '#00dfff', '#00efff', '#00ffff', '#10ffef', '#20ffdf', '#30ffcf', '#40ffbf',
            '#50ffaf', '#60ff9f', '#70ff8f', '#80ff80', '#8fff70', '#9fff60', '#afff50',
            '#bfff40', '#cfff30', '#dfff20', '#efff10', '#ffff00', '#ffef00', '#ffdf00',
            '#ffcf00', '#ffbf00', '#ffaf00', '#ff9f00', '#ff8f00', '#ff8000', '#ff7000',
            '#ff6000', '#ff5000', '#ff4000', '#ff3000', '#ff2000', '#ff1000', '#ff0000',
            '#ef0000', '#df0000', '#cf0000', '#bf0000', '#af0000', '#9f0000', '#8f0000',
            '#800000');
            
  my $geomean = $fsdata->{'geomean'};
  $geomean = $BAR_MIN if $geomean < $BAR_MIN;
  $geomean = $BAR_MAX if $geomean > $BAR_MAX;
  my $nbin = scalar(@cm);
  my $ix = int($nbin * (log($geomean / $BAR_MIN)) / log(($BAR_MAX+1) / $BAR_MIN));
  
  print OUT '<table role="presentation"><tr><td>', "\n"; 
  
  print OUT '<table id="fsbar" role="presentation">', "\n";
  print OUT '<caption style="display: none">field strength bar</caption>', "\n";
  
  print OUT '<tr class="topbot">';
  if ($ix > 0) { print OUT '<td colspan="', $ix, '"></td>'; }
  print OUT '<td style="background-color: black"></td>';
  if ($ix < $#cm) { print OUT '<td colspan="', $#cm - $ix, '"></td>'; }
  print OUT '</tr>', "\n";
  
  print OUT '<tr class="middle">';
  foreach my $i (0..$#cm) {
    print OUT '<td style="background-color: ', $i == $ix ? 'black' : $cm[$i], '"></td>';
  }
  print OUT '</tr>', "\n";

  print OUT '<tr class="topbot">';
  if ($ix > 0) { print OUT '<td colspan="', $ix, '"></td>'; }
  print OUT '<td style="background-color: black"></td>';
  if ($ix < $#cm) { print OUT '<td colspan="', $#cm - $ix, '"></td>'; }
  print OUT '</tr>', "\n";

  print OUT '</table>', "\n";
  
  print OUT '</td>', "\n"; 
  my $fstext = sprintf('Field strength:&nbsp;&nbsp;Mean: %d MP&nbsp;&nbsp;Geomean: %d MP<br>(based on %d players',
      $fsdata->{'mean'}, $fsdata->{'geomean'}, $fsdata->{'ndata'});
  if ( $fsdata->{'nNonMember'} ) {
    my $plural = $fsdata->{'nNonMember'} > 1 ? 's' : '';
    $fstext .= ", $fsdata->{'nNonMember'} non ACBL player$plural ignored";
  }
  if ( $fsdata->{'nFail'} ) {
    my $plural = $fsdata->{'nFail'} > 1 ? 's' : '';
    $fstext .= ", missing masterpoint data for $fsdata->{'nFail'} ACBL player$plural";
  }
  $fstext .= ')';
  
  print OUT '<td style="padding-left: 1em">', $fstext, '</td>', "\n", '</tr></table>', "\n\n";
}

sub ddmakeshand {
  # Print HTML table of double dummy makable contracts for each side.
  # $hd{'dd'} encodes number of tricks the N-S can make if lead is from
  # SENW respectively (note SENW is CCW not the expected CW as bridge is
  # played) for each of the five denominations. A=10, B=11, etc.
  my ($hd) = @_;
  my $dd = $hd->{'dd'};
  my @denoms = ('NT', '&spades;', '&hearts;', '&diams;', '&clubs;');

  print OUT '    <td>', "\n";
  print OUT '      <table class="DDmakes">', "\n";
  print OUT '        <tr><td><span class="ul">Double Dummy Makes</span></td></tr>', "\n";
  for my $i (0..1) {
    # Number of character display. Used to determine when to wrap the
    # double dummy output.
    my $nchar = 0;
    print OUT '        <tr><td>';
    if ($i==0) { print OUT 'NS:'; } else { print OUT 'EW:';}
    # S1 is string of makeable contracts (from at least one side).
    # S2 is string of unmakeable contracts (from at least one side).
    my $s1 = ''; my $s2 = '';
    for (my $j=4; $j>=0; $j--) {
      my ($t1, $t2);
      if ($i==0) {
        # T1 = North tricks; T2 = South tricks
        $t1 = hex substr($dd,$j*4+1,1); $t2 = hex substr($dd,$j*4+3,1);
      }
      else {
        # T1 = East tricks; T2 = West tricks
        $t1 = hex substr($dd,$j*4,1); $t2 = hex substr($dd,$j*4+2,1);
        $t1 = 13 - $t1; $t2 = 13 - $t2;
      }
      
      if ($t1 > 6 || $t2 > 6) {
        # At least one side can make a contract in this denomination.
        if ($t1 == $t2) {
          $s1 .= '&nbsp;' . ($t1-6); $nchar += 3;
        }
        else {
          $s1 .= '&nbsp;';
          if ($t1 > 6) {$s1 .= ($t1-6) . '/'; } else {$s1 .= '-/';}
          if ($t2 > 6) {$s1 .= ($t2-6); } else {$s1 .= '-'};
          $nchar += 5;
        }
        if ($j == 2 || $j == 3) {
          $s1 .= '<span class="hs">' . $denoms[$j] . '</span>';
        }
        elsif ($j == 3) {
          $s1 .= '<span class="ds">' . $denoms[$j] . '</span>';
        }
        else {
          $s1 .= $denoms[$j];
        }
        if ($j == 0) { $nchar++; }
      }
      
      if ($t1 <= 6 || $t2 <= 6) {
        # At least one side fails in this denomination.
        $s2 .= ' ' . $denoms[$j];
        if ($t1 == $t2) {
          $s2 .= $t1; $nchar += 3;
        }
        else {
          $s2 .= $t1 . '/' . $t2; $nchar += 5;
        }
        if ($j == 0) { $nchar++; }
      }

    }
    print OUT $s1;
    if ($s2 ne '') {
      if ($nchar > 23) { print OUT '<br>', '&nbsp;' x 5; }
      print OUT '&nbsp;<span class="ddfail">', $s2, '</span>';
    }
    print OUT '</td></tr>', "\n";
  }
  print OUT '      </table>', "\n";
  print OUT '    </td>', "\n";

}

sub LoTTstats {
  # Computes Law of Total Tricks (LoTT) statistics:
  # 1. Sum of trump length in best fits for N-S and E-W
  # 2. Sum of tricks taken in best fit(s) for N-S and E-W. If there
  #    are multiple fits of the same length, use the fit that yields
  #    the maximum number of tricks 
  my ($hd) = @_;
  my $dd = $hd->{'dd'};

  my $total_tricks = 0;
  my $total_trumps = 0;
  for my $i (0..1) {
  	my (@h1, @h2);
    if ($i==0) {
      @h1 = split /\./, $hd->{'north'};
      @h2 = split /\./, $hd->{'south'};
    }
    else {
      @h1 = split /\./, $hd->{'east'};
      @h2 = split /\./, $hd->{'west'};
    }
    my $best_fit_length = 0;
    my $best_fit_tricks = 0;
    # Start at 1 rather than 0 because NT contracts are considered for LoTT.
    for (my $j=1; $j<=4; $j++) {
      my ($t1, $t2);
      if ($i==0) {
				# T1 = North tricks; T2 = South tricks
				$t1 = hex substr($dd,$j*4+1,1); $t2 = hex substr($dd,$j*4+3,1);
      }
      else {
				# T1 = East tricks; T2 = West tricks
				$t1 = hex substr($dd,$j*4,1); $t2 = hex substr($dd,$j*4+2,1);
				$t1 = 13 - $t1; $t2 = 13 - $t2;
      }
      # LoTT assumes contract is played in best seat.
      my $fit_tricks = ($t1 > $t2) ? $t1 : $t2;
      my $fit_length = (defined $h1[$j-1] ? length($h1[$j-1]) : 0) +
				(defined $h2[$j-1] ? length($h2[$j-1]) : 0);
      if ($fit_length > $best_fit_length ||
	  		($fit_length == $best_fit_length && $fit_tricks > $best_fit_tricks)){
				$best_fit_tricks = $fit_tricks;
				$best_fit_length = $fit_length;
      }
    }
    $total_tricks += $best_fit_tricks;
    $total_trumps += $best_fit_length;
  }
  return ($total_tricks, $total_trumps);
}

sub rawscore {
  # Computes score for undoubled contract or a doubled contract with
  # for a given number of undertricks. These are the only possibilities
  # for a par contract (aside from a passed out hand). 
  #
  # DENOM  - 0 = NT, 1 = Spades, 2 = Hearts, 3 = Diamonds, 4 = Clubs
  #          (same order as results from double dummy solver); -1 undertricks
  # TRICKS - For making contracts (7-13); otherwise, number of undertricks.
  # ISVUL  - True if vulnerable
  my ($denom, $tricks, $isvul) = @_;
  my ($level, $score);
  if ($denom == -1) {
    if ($isvul) { return -300 * $tricks + 100; }
    if ($tricks <= 3) { return -200 * $tricks + 100; }
    return -300 * $tricks + 400;
  }
  else {
    $level = $tricks - 6;
    my $game_bonus = 0;
    if ($denom == 0) {
      $score = 10 + 30 * $level;
      $game_bonus = 1 if $level >= 3;
    }
    elsif ($denom == 1 || $denom == 2) {
      $score = 30 * $level;
      $game_bonus = 1 if $level >= 4;
    }
    else {
      $score = 20 * $level;
      $game_bonus = 1 if $level >= 5;
    }
    if ( $game_bonus ) { $score += ($isvul ? 500 : 300); } else {$score += 50;}
    # Slam and Grand Slam bonuses
    $score += ($isvul ?  750 : 500 ) if $level == 6;
    $score += ($isvul ? 1500 : 1000) if $level == 7; 
  }
  return $score;
}

sub par {
  # Computes the par result and contract.
  my ($hd, $vul) = @_;
  
  # In principle, the par contract is easy to understand -- it is the
  # contract beyond which neither side can bid to improve their result.
  # But in determining the par contract, a number of subtleties arise.
  #
  # 1. If neither side can make anything (very rare), 0 (passed out) is
  #    the par result.
  # 2. There may be multiple par contracts, e.g. both 4H and 4S or 5C and
  #    5D if they take the same number of tricks, 3N and 5C/5D, 3m and 2M,
  #    or multiple contracts in which a sacrifice costs the same number of
  #    undertricks.
  # 3. If only one seat can make the par contract that should be indicated,
  #    i.e. 4H-E instead of 4H-EW.
  # 4. When a sacrifice is not the par result, the highest scoring contract
  #    may not be the par contract. For example, if there is a vulnerable 
  #    down two sacrifice (+500) against a vulnerable 4H (+620), but 5D (+600)
  #    also makes, then +600 is the par result.
  # 5. If both sides can make the same contract (typically 1N) we have a
  #    "hot" situation in game theory where the first side to bid it will
  #    win. Par should be reported as +-VAL rather than 0. In extremely
  #    rare perverse cases (think Victor Mollo), both sides may be able
  #    to make the same game. If the vulnerabilities are different, we
  #    end up with something like +620/-420.

  my $dd = $hd->{'dd'};
  my $DEBUG = 0;
  ## return (0, 0, 'Par: Pass Out', ['PASS']) if $hd->{'dd'} !~ /^8787/;

  # Two elements because par calculation will run from each side just in
  # case there is a "hot" situation.
  my @par_denom   = (-1, -1);  # 0-4 = NT,S,H,D,C
  my @par_tricks  = (6, 6);    # Initial "contract" beats 0 NT
  my @par_score   = (0, 0);
  my @par_sacut   = (0, 0);    # Undertricks for sacrifice (0 if not sac)
  
  # Best making contract other side had before it was beat by the final
  # par contract. Need this when determining alternate par contracts.
  my @lpar_denom  = (-1, -1);
  my @lpar_tricks = (0 , 0);
  
  # Allocate once for efficiency.
  my ($i, $j, $k);
  my ($new_score_flag, $new_par_tricks, $new_par_denom);
  my ($isvul, $ut, $t1, $t2, $tt, $score);

  # Find best par result for N-S ($i==0) or E-W ($i==1). These will
  # nearly always be the same, but when we have a "hot" situation
  # they will not be.  
  for $i (0..1) {
    # Start with the with the offensive side ($current_side = 0) and alternate
    # between sides seeking to improve the result for the current side.
    my $current_side = 0; my $both_sides_once_flag = 0;
    while (1) {
      # Find best contract for current side that beats current contract.
      # Choose highest contract if results are equal.
      $k = ($i + $current_side) % 2;
      $isvul = ($vul eq 'Both') || ($k ? $vul eq 'E-W' : $vul eq 'N-S');
      $new_score_flag = 0;
      
      for ($j=0; $j<=4; $j++) {
				# $TT is the maximum number of tricks current side can take in denomination.
				$t1 = $k ? 13 - hex substr($dd,$j*4,1)   : hex substr($dd,$j*4+1,1);
				$t2 = $k ? 13 - hex substr($dd,$j*4+2,1) : hex substr($dd,$j*4+3,1);
        $tt = ($t1 > $t2) ? $t1 : $t2;
        
        if ($tt > $par_tricks[$i] || ( $tt == $par_tricks[$i] && $j < $par_denom[$i] ) )  {
          # Can bid higher and make contract.
          $score = rawscore($j, $tt, $isvul);
          print "$i $current_side S$j, $tt, ", $isvul ? 'V' : 'NV', " $score  " if $DEBUG;
        }
        else {
          # Bidding higher in this denomination will not beat previous denomination
          # and may be a sacrifice.
          $ut = $par_tricks[$i] - $tt;
          if ($j >= $par_denom[$i]) {
            # Sacrifices higher than 7N are not permitted (but long ago
            # the official rules did not prohibit bidding higher than 7N!)
            if ($par_tricks[$i] == 13) { next; }
            # It will be necessary to bid one level higher, resulting in
            # one more undertrick.
            $ut++;
          }
          # Not a sacrifice (due to $new_par_tricks > $par_tricks[$i])
          if ($ut <= 0) { next; }
          # Compute sacrifice.
          $score = rawscore(-1, $ut, $isvul);
          print "$i $current_side U$j, $ut ", $isvul ? 'V' : 'NV', " $score  " if $DEBUG
        }
        $score = -$score if $current_side == 1;

        if (($current_side == 0 && $score > $par_score[$i]) ||
            ($current_side == 1 && $score < $par_score[$i])) {
          $new_score_flag = 1;
          $par_score[$i] = $score;
          $new_par_denom = $j;
          if (($current_side == 0 && $score > 0) ||
              ($current_side == 1 && $score < 0) ) {
            # New par score from a making contract.
            $new_par_tricks = $tt; $par_sacut[$i] = 0;
          }
          else {
            # New par score from a sacrifice contract.
            $new_par_tricks = $tt + $ut; $par_sacut[$i] = $ut;
          }
        }
        print "\n" if $DEBUG
      }
      if ($new_score_flag) {
         $lpar_tricks[$i] = $par_tricks[$i];
         $lpar_denom[$i]  = $par_denom[$i];
         $par_tricks[$i]  = $new_par_tricks;
         $par_denom[$i]   = $new_par_denom;
      }
      if ($DEBUG) {
        printf "par: %5d  %d %d  new_flag: %d\n", $par_score[$i], $par_denom[$i],
        $par_tricks[$i], $new_score_flag;
        printf "lpar: %d %d\n", $lpar_denom[$i], $lpar_tricks[$i];
      }
      
      if (! $new_score_flag && $both_sides_once_flag) { last; }
      $both_sides_once_flag = 1;
      $current_side = 1 - $current_side;
    }
    print "---\n" if $DEBUG
  }

  # Construct par HTML string and a JSON based representation.
  if ($par_score[0] == 0) {
    # Neither side can make anything.
    return (0, 0, 'Par: Pass Out', ['PASS']);
  }

  my @denomHTML = ('NT', '&spades;', '<span class="hs">&hearts;</span>',
		'<span class="ds">&diams;</span>', '&clubs;');
  my $denomLetters = 'NSHDC';

  my $str = 'Par: ';
  my @par_contracts = ();

  my $ishot = ($par_score[0] == $par_score[1] && $par_denom[0] == $par_denom[1]);
  # Will almost always execute this loop only once.
  for $i (0..1) {
    my @strpar = ();
    my $bidplus6;
    if ( $par_sacut[$i] > 0 ) {
      # Par contract is a sacrifice.
      if ( $par_score[$i] > 0 ) { $str .= '+' }
      $str .= $par_score[$i] . ' ';
      # $DR = 0 -> EW, 1 -> NS (which side is sacrificing)
      my $dr = ($par_score[$i] > 0) ? 0 : 1;
      # There may be multiple sacrifice contracts. Note: These can be at a different
      # level. For example, 4S*-1 might be the lowest par contract over a making 4H
      # contract but 5C*-1 might also be a par contract. Any other sacrifice contracts
      # must be in a lower ranking denomination than the par denomination found above
      # because the highest ranking denomination is always found above.
      for ($j=$par_denom[$i]; $j<=4; $j++) {
        # T1 = North/East tricks; T2 = South/West tricks
        $t1 = hex substr($dd,$j*4+$dr,1); $t2 = hex substr($dd,$j*4+2+$dr,1);
        # If sacrifice against N-S, convert to number of tricks E-W can take.
        if ($dr==0) { $t1 = 13 - $t1; $t2 = 13 - $t2; }
        $tt = ($t1 > $t2) ? $t1 : $t2;
        $bidplus6 = $par_tricks[$i];
        # Alternate sacrifice contract may be one level higher. 
        $bidplus6++ if $par_tricks[$i] == $lpar_tricks[$i] && $j >= $lpar_denom[$i];
        # Can't be < because then we would have found a better par contract above.
        if ($bidplus6 - $par_sacut[$i] != $tt) { next; }

        my $stmp    = $bidplus6 - 6 . $denomHTML[$j] . '*-';
        my $JSONpar = $bidplus6 - 6 . substr($denomLetters,$j,1) . '*-';
        if ($dr==0) {
          if ($t1 == $tt) { $stmp .= 'E'; $JSONpar .= 'E'; }
          if ($t2 == $tt) { $stmp .= 'W'; $JSONpar .= 'W'; }
        }
        else {
          if ($t1 == $tt) { $stmp .= 'N'; $JSONpar .= 'N'; }
          if ($t2 == $tt) { $stmp .= 'S'; $JSONpar .= 'S'; }
        }
        $JSONpar .= '-' . $par_sacut[$i];
        push @strpar, $stmp;
        push @par_contracts, $JSONpar;
      }
      $str .= join('/', @strpar) . '-' . $par_sacut[$i];
    }
    else {
      # Par contract is a makeable contract.
      if ( $ishot ) { $str .= '&plusmn;'; }
      elsif ( $par_score[$i] > 0 ) { $str .= '+' }
      $str .= $par_score[$i] . ' ';
      # $DR = 0 -> EW, 1 -> NS (which side is making)
      my $dr = ($par_score[$i] < 0) ? 0 : 1;

      # If spades or diamonds is the par contract, lower major / minor may also
      # be a par contract.
      my $ke = ($par_denom[$i] == 1 || $par_denom[$i] == 3) ? 1 : 0;
      for ($j=$par_denom[$i]; $j<=$par_denom[$i]+$ke; $j++) {
        # T1 = North/East tricks; T2 = South/West tricks
        my $t1 = hex substr($dd,$j*4+$dr,1); my $t2 = hex substr($dd,$j*4+2+$dr,1);
        if ($dr==0) { $t1 = 13 - $t1; $t2 = 13 - $t2; }
        my $tt = ($t1 > $t2) ? $t1 : $t2;
        if ($tt < $par_tricks[$i]) { next; }
        my $stmp    = $par_tricks[$i] - 6 . $denomHTML[$j] . '-';
        my $JSONpar = $par_tricks[$i] - 6 . substr($denomLetters,$j,1) . '-';
        if ($dr == 0 || $ishot) {
          if ($t1 == $tt) { $stmp .= 'E'; $JSONpar .= 'E'; }
          if ($t2 == $tt) { $stmp .= 'W'; $JSONpar .= 'W'; }
        }
        if ($dr == 1 || $ishot) {
          if ($t1 == $tt) { $stmp .= 'N'; $JSONpar .= 'N'; }
          if ($t2 == $tt) { $stmp .= 'S'; $JSONpar .= 'S'; }
        }
        push @strpar, $stmp;
        push @par_contracts, $JSONpar;
      }
      
      # Deal with special case of 3N/5m (+400/600)
      if ($par_denom[$i] == 0 && $par_tricks[$i] == 9) {
        for $j (3..4) {
          # T1 = North/East tricks; T2 = South/West tricks
          $t1 = hex substr($dd,$j*4+$dr,1); my $t2 = hex substr($dd,$j*4+2+$dr,1);
          if ($dr==0) { $t1 = 13 - $t1; $t2 = 13 - $t2; }
          $tt = ($t1 > $t2) ? $t1 : $t2;
          if ($tt != 11) { next; }
          my $stmp    = '5' . $denomHTML[$j] . '-';
          my $JSONpar = '5' . substr($denomLetters,$j,1) . '-';
          if ($dr == 0) {
            if ($t1 == $tt) { $stmp .= 'E'; $JSONpar .= 'E'; }
            if ($t2 == $tt) { $stmp .= 'W'; $JSONpar .= 'W'; }
          }
          else {
            if ($t1 == $tt) { $stmp .= 'N'; $JSONpar .= 'N'; }
            if ($t2 == $tt) { $stmp .= 'S'; $JSONpar .= 'S'; }
          }
          push @strpar, $stmp;
          push @par_contracts, $JSONpar;
        }
      }
      
      # Deal with special case of 2S/2H (+110) which may have 3C and 3D
      # as additional par contract(s).
      if ($par_denom[$i] <=2 && $par_score[$i] == 110) {
        # Check if 3C and 3D make.
        for my $j (3..4) {
          my $t1 = hex substr($dd,$j*4+$dr,1); my $t2 = hex substr($dd,$j*4+2+$dr,1);
          if ($dr==0) { $t1 = 13 - $t1; $t2 = 13 - $t2; }
          my $tt = ($t1 > $t2) ? $t1 : $t2;
          if ($tt != 9) { next; }
          my $stmp    = '3' . $denomHTML[$j] . '-';
          my $JSONpar = '3' . substr($denomLetters,$j,1) . '-';
          if ($dr == 0) {
            if ($t1 == $tt) { $stmp .= 'E'; $JSONpar .= 'E'; }
            if ($t2 == $tt) { $stmp .= 'W'; $JSONpar .= 'W'; }
          }
          else {
            if ($t1 == $tt) { $stmp .= 'N'; $JSONpar .= 'N'; }
            if ($t2 == $tt) { $stmp .= 'S'; $JSONpar .= 'S'; }
          }
          push @strpar, $stmp;
          push @par_contracts, $JSONpar;
        }
      }
      $str .= join('/', @strpar);

    }

    if (!$ishot || $par_denom[0] == $par_denom[1]) { last; }
    
    # Extremely rare case of alternate hot contracts, e.g. each side
    # can sacrifice in 3C* or 3D* respectively for -100 against 2N
    # making +120 in either direction.
    if ($i == 0) { $str .= ', '; }
  }

  # Return par score for N-S and E-W (same unless situation is hot) and HTML string. 
  # 0 + coerces internal Perl datatype to numeric, yielding an unquoted value in 
  # JSON output.
  return (0 + $par_score[0], -$par_score[1], $str, \@par_contracts);
}

sub approxMP {
  # Converts number of masterpoints to an approximate number.
  my ($val) = @_;
  if ($val < 10) { return int($val + 0.5); }
  my $pow10 = exp( int(log($val) / log(10) - 1) * log(10) );
  return int($val / $pow10 + 0.5) * $pow10;
}

sub mpmeans {
  # Compute arithmetic and geometric means of a list of masterpoints.
  if (scalar(@_) != 1) { die "function requires 1 argument."; }
  my($pmp) = @_;
  die "PMP must be an arrayref." if (ref($pmp) ne 'ARRAY');
  
  my $ndata = 0; my $sum = 0; my $lsum = 0;
  foreach my $mp (@$pmp) {
    $ndata++;
    $sum += $mp;
    # Log(0) is a problem. Also do not want players with say 0.1 MP to unduly drag
    # down the geometric mean. Set minimum at 1 MP.
    if ($mp < 1) {$mp = 1;}
    $lsum += log($mp);
  }
  
  if ($ndata == 0) { return(0, undef, undef); }
  return ($ndata, $sum / $ndata, exp($lsum/$ndata));
}

sub teamMPmeans {
  # Computes masterpoint mean and geomean and (seed) rank for each team.
  if (scalar(@_) != 4) { die "function requires 4 arguments."; } 
  my ($gametype, $pyteams, $pnn, $pmp) = @_;
  my (%teamMP, $pnum, $mp);

  foreach my $teamnum (keys %$pyteams) {
    my @mp;
    # Usually the latter case, but deal with BAM too.
    my $playerNames = $gametype eq 'BAM' ? $pyteams->{$teamnum}{'players'} : $pyteams->{$teamnum};
    foreach my $playerName (@$playerNames) {
      $pnum = $pnn->{$playerName};
      next if !$pnum;
      $mp = $pmp->{$pnum};
      push @mp, $mp if defined $mp;
    }
    (undef, $teamMP{$teamnum}{'mean'}, $teamMP{$teamnum}{'geomean'}) = mpmeans(\@mp);
  }
  my @teamnums = keys %$pyteams;
  @teamnums = sort {
    $teamMP{$b}{'geomean'} <=> $teamMP{$a}{'geomean'} || 
    $teamMP{$b}{'mean'} <=> $teamMP{$a}{'mean'}
  } @teamnums;
  for (my $i=0; $i<=$#teamnums; $i++) { $teamMP{$teamnums[$i]}{'seedgeorank'} = $i+1; }
  return \%teamMP;
}

sub lookupMP {
  # Lookup masterpoint holdings for list of canonicalized player numbers.
  #
  # PPNUMS   - Arrayref of player numbers
  # MPDBNAME - Name of masterpoint database file
  if (scalar(@_) != 2) { die "function requires 2 arguments."; }
  my ($ppnums, $MPdbname) = @_;
  die "PPNUMS must be an arrayref." if (ref($ppnums) ne 'ARRAY');
  
  my (%pmp, @mpfail);
  # Don't read database if there are no player numbers to lookup.
  if (scalar(@$ppnums) == 0) { return ('', %pmp, @mpfail); }

  my @pnums = sort {$a <=> $b} @$ppnums;
  
  open(my $fh, '<', $MPdbname) or return("Unable to open/read: $MPdbname ($!)");
  binmode($fh);

  # Check header.
  read($fh, my $id, 4);
  if ($id ne 'MPDB') { return "Not an ACBLmerge masterpoint database: $MPdbname"; }
  # Skip over year and month data.
  read($fh, my $yyyymm, 4);
  my ($db_year, $db_mon) = unpack('nn', $yyyymm);

  local $/ = undef;
  my $data = <$fh>;
  close($fh);
  
  my $ix = 0; my $dlen = length($data);
  my $ar_pnum = shift(@pnums);
  my $db_pnum = unpack('N', substr($data, $ix, 4));
  
  # Perform sort merge lookup.
  while (1) {
    if ($db_pnum < $ar_pnum) {
      $ix += 8; if ($ix >= $dlen) { last; }
      $db_pnum = unpack('N', substr($data, $ix, 4));
    }
    elsif ($ar_pnum == $db_pnum) {
      $pmp{$db_pnum} = unpack('N', substr($data, $ix+4, 4)) / 100;
      $ix += 8; if ($ix >= $dlen) { last; }
      $db_pnum = unpack('N', substr($data, $ix, 4));
      $ar_pnum = shift(@pnums);
      if (!defined $ar_pnum) { last; }
    }
    else {
      push @mpfail, $ar_pnum;
      $ar_pnum = shift(@pnums);
      if (!defined $ar_pnum) { last; }
    }
  }
  
  push @mpfail, $ar_pnum if $ar_pnum;
  push @mpfail, @pnums;

  return ('', \%pmp, \@mpfail, $db_year, $db_mon);
}

sub playerNumsAndNames {
  # Reads player numbers and names directly from an ACBLscore game file.
  # Non ACBL members are ignored.
  if (scalar(@_) != 1) { die "function requires 1 argument."; }
  my ($fname) = @_;
  
  # Try to parse binary ACBLscore output. This format isn't documented but the player
  # information doesn't look really complicated. Fields, are preceded by a field length
  # byte, which for the player number is always 7.
  local $/; 
  open(my $fh, '<', $fname) or return("Unable to open/read ACBLscore gamefile: $fname");
  binmode($fh);
  my $data = <$fh>;
  close($fh);
  
  # Check that start of file looks like an ACBLscore game file
  if ( substr($data,0,6) ne "\x12\x0a\x03AC3" ) {
    print STDERR "ACBLscore game file does not appear to be a game file. First six bytes are not\n";
    print STDERR "0x12 0x0a 0x03 AC3. Input filename was: $fname\n";
    exit($EXIT_NOT_GAMEFILE);
  }
  
  my %pnn;
  my $ix = -1;
  my ($pnum, $val, $firstname, $lastname, $fullname, $fdlen);
  # This ignores non ACBL members because they have chr(2) 'NM' (non-member)
  # where the 7 character player number would normally be.
  while( ($ix = index($data, chr(7), $ix+1)) != -1 ) {
    if ($ix > length($data) - 6) { last; } 
  
    $pnum = substr($data, $ix+1, 7);
    if ( $pnum !~ /^[0-9J-S][0-9]{6}$/ ) { next; }
    
    # Canonicalize Life Masters.
    $val = ord(substr($pnum,0,1));
    if ($val > 57) { $val -= 25; substr($pnum,0,1) = chr($val); }
    
    # Find the player's first and last names.
    $fdlen = ord(substr($data, $ix-37, 1));
    $firstname = substr($data, $ix-36, $fdlen);

    $fdlen = ord(substr($data, $ix-54, 1));
    $lastname = substr($data, $ix-53, $fdlen);
    $fullname = $firstname . ' ' . $lastname;
    
    # The field used print the player's name in the ACBL text and HTML reports is
    # limited to 22 characters and that is the field that will be used to lookup
    # the player number using the hash returned by this subroutine.
    $fullname = substr($fullname,0,22) if length($fullname) > 22;
    
    $pnn{$fullname} = $pnum;
  }
  return('', \%pnn);
} 

sub checkMPdb {
  # Checks if Masterpoint Database exists and is current. Create it or
  # update it using latest Club Update Database if necessary.

  if (scalar(@_) != 1) { die "function requires 1 argument."; }
  my ($MPdbname) = @_;
  
  my $clubfname = appDir() . 'D00MP.LZH';
  
  my $errmsg;
  my $outofdate = 0;

  # The ACBL usually releases a new update of the Club Database on the 7th
  # of each month. But allow some slop - don't try to get the new update
  # unless it is the 10th of the month or later.
  (undef, undef, undef, my $mday, my $mon, my $year) = localtime(time);
  my $want_mon = $mon + 1; my $want_year = $year + 1900;
  if ($mday < 10) {
    $want_mon--;
    if ($want_mon == 0) { $want_mon += 12; $want_year--; }
  }

  if (-f $MPdbname) {
    open(my $fh, '<', $MPdbname) or return('Unable to open/read: $MPdbname ($!)');
    binmode($fh);
  
    # Check header.
    read($fh, my $id, 4);
    if ($id ne 'MPDB') { return "Not a masterpoint database: $MPdbname"; }
    # Skip over year and month data.
    read($fh, my $yyyymm, 4);
    my ($db_year, $db_mon) = unpack('nn', $yyyymm);
    
    if ($db_year != $want_year || $db_mon != $want_mon) { $outofdate = 1; }
    
  }
  
  if ( $outofdate && ! $opt{'quiet'} ) {
    print STDERR "Masterpoint database is out of date. Updating...\n";
  }
  
  {
    if (!-f $MPdbname || $outofdate) {
      if (! $opt{'quiet'}) {
        print STDERR "Fetching new ACBL Club Update database from the ACBL website...\n";
      }
      $errmsg = fetchClubUpdate($clubfname);
      if ($errmsg) {
        if (! $opt{'quiet'}) { print STDERR "Failed: $errmsg\n"; }
        if ($outofdate) {
          if (! $opt{'quiet'}) { print STDERR "Using out of date masterpoint database.\n"; }
          $errmsg = ''; last;
        }
        else { last; }
      }

      if (! $opt{'quiet'}) { print STDERR "Unpacking ACBL Club Update database...\n"; }
      my $data = readLHZfile($clubfname);
      unlink($clubfname);
      if (! $opt{'quiet'}) { print STDERR "Writing compacted masterpoint database: $MPdbname\n"; }
      $errmsg = writeMPdb($data, $MPdbname, $want_year, $want_mon);
    }
  }
  return($errmsg);
}

sub fetchClubUpdate {
  # Fetches ACBL Club Update file (the one that includes players from all Districts).
  if (scalar(@_) != 1) { die "function requires 1 argument."; }
  my ($ofname) = @_;
  
  requirePackage('LWP::UserAgent', 'Fetching ACBL Club Update database');

  my $URL = 'http://web2.acbl.org/mpfiles/D00MP.LZH';

  # Create a user agent object.
  my $ua = LWP::UserAgent->new;
  $ua->agent('ACBLmerge');
  $ua->timeout(10);

  # Create a request.
  my $req = HTTP::Request->new(GET => $URL);
  $req->header(Accept => "text/html, */*;q=0.1");

  # Pass request to the user agent and get a response back.
  my $res = $ua->request($req);

  # Check the outcome of the response
  if ($res->is_success) {
	  open(my $fh, '>', $ofname) or return "Can't open/write: $ofname";
	  binmode($fh);
	  print $fh $res->content;
	  close($fh);
	}
	else {
	  return $res->status_line;
	}
	
	return('');
}

sub readLHZfile {
  # read LHZ archive that contains a single file.
  if (scalar(@_) != 1) { die "function requires 1 argument."; }
  my ($fname) = @_;
  
  if ( ($^O eq 'MSWin32' && $USE_7ZIP_ON_WINDOWS) || ($^O eq 'darwin' && $USE_7ZIP_ON_OSX) ) {
	  # Need to use 7z because the standalone 7za program does not support LZH format.
    my $PROG_BNAME = $^O eq 'MSWin32' ? '7z.exe' : '7z';
    my $PROG_DLL   = $^O eq 'MSWin32' ? '7z.dll' : '7z.so';
    my $prog_path = ($^O eq 'MSWin32' ? $SCRIPTPATH : $MAC_OS_X_PATH) . $PROG_BNAME;
    my $prog_dll  = ($^O eq 'MSWin32' ? $SCRIPTPATH : $MAC_OS_X_PATH) . $PROG_DLL;
    
    if (! -e $prog_path) {
      print STDERR "Missing application file: $prog_path\n"; exit($EXIT_7ZIP_ERROR);
    }
    if (! -e $prog_dll) {
      print STDERR "Missing application file: $prog_path\n"; exit($EXIT_7ZIP_ERROR);
    }
    if (! -x $prog_path) {
      print STDERR "Application file is not executable: $prog_path\n"; exit($EXIT_7ZIP_ERROR);
    }
  
	  # 7z doesn't seem to have a switch for a "quiet" mode, so redirect STDERR to nul.
	  open(my $fh, "\"$prog_path\" e -so \"$fname\" 2> nul |");
	  if ($! =~ /not recognized as an internal or external command/ ||
	      $! =~ /Missing application file/ ) {
	    print STDERR "Problem using $PROG_BNAME.\n"; exit($EXIT_7ZIP_ERROR);
	  }
	  binmode($fh);
	  local $/ = undef;
	  my $data = <$fh>;
	  close($fh);
	  return $data;
  }

  # Otherwise rely on a Perl package that is not longer supported and which has been
  # removed from CPAN, though it is still available from backPAN.
  requirePackage('Archive::Lha', 'Reading ACBL Club Masterpoint Update file');
  
  # These packages will automatically be installed as dependencies of Archive::Lha
  require Archive::Lha::Stream;
  require Archive::Lha::Header;
  require Archive::Lha::Decode;

  my $data;

  my $stream = Archive::Lha::Stream->new(file => $fname);
  my $level = $stream->search_header;

  my $header = Archive::Lha::Header->new( level => $level, stream => $stream );
  $stream->seek($header->data_top);
  
  my $decoder = Archive::Lha::Decode->new(
    header => $header,
    read   => sub { $stream->read(@_) },
    write  => sub { $data .= $_[0]; }
  );
  
  my $crc = $decoder->decode;
  die "crc mismatch" if $crc != $header->crc16;
  
  return $data;
}

sub writeMPdb {
  # Repacks Club Update Database data in a sorted format geared for relatively
  # fast access without the need to load all the player information into memory.
  #
  # DATA   - Unpacked ACBL Club Update Database
  # OFNAME - Output filename for repacked Masterpoint Database
  # YEAR   - Year (4-digit) for version of Club Update Database
  # MON    - Month (1-12) for version of Club Update Database
  if (scalar(@_) != 4) { die "function requires 4 arguments."; }
  my ($data, $ofname, $year, $mon) = @_;
  
  open(my $fh, '>', $ofname) or return('Unable to open/write: $ofname ($!)');
  binmode($fh);

  my %mp;
  my ($pnum, $val);
  for ( my $ix=0; $ix < length($data); $ix += 23 ) {
    $pnum = substr($data, $ix, 7);
    # Canonicalize Life Masters.
    $val = ord(substr($pnum,0,1));
    if ($val > 57) { $val -= 25; substr($pnum,0,1) = chr($val); }
    $mp{$pnum} = substr($data, $ix+13, 8) * 100;
  }
  
  print $fh 'MPDB', pack('nn', $year, $mon);
  foreach my $pnum (sort {$a <=> $b} keys %mp) { print $fh pack('NN', $pnum, $mp{$pnum}); }
  close($fh);
  
  return('');
}

sub dmJSONpairs {
  # Dumps information about the event, the pairs, and the results on each board
  # in JSON format.
  if (scalar(@_) != 12) { die "function requires 12 arguments."; }
  my ($dmfname, $evt, $sections, $phd, $ppy, $pnn, $fsdata, $pbdata,
    $bsc, $bws, $bwsHasConts, $bwsHasLeads) = @_;
  requirePackage('JSON::PP', 'Creating JSON data mining file');
  
  my $isBAM = $evt->{'gametype'} eq 'BAM';
  if ($fsdata) { $evt->{'fs'} = $fsdata; }
  if ($pnn) {
    if ($isBAM) {
      foreach my $team_id (keys %$ppy) {
        my @pnums;
        foreach my $player ( @{$ppy->{$team_id}{'players'}} ) { push @pnums, $pnn->{$player}; }
        $ppy->{$team_id}{'pnums'} = \@pnums;
      }      
    }
    else {
      foreach my $pair_id (keys %$ppy) {
        if ( !defined $ppy->{$pair_id}{'pnum1'} ) {
          $ppy->{$pair_id}{'pnum1'} = $pnn->{$ppy->{$pair_id}{'player1'}};
        }
        if ( !defined $ppy->{$pair_id}{'pnum2'} ) {
          $ppy->{$pair_id}{'pnum2'} = $pnn->{$ppy->{$pair_id}{'player2'}};
        }
      }
    }
  }
  # Package board results. This is similar to code in JSvars but for cleaner JSON.
  my @bnums = sort {$a <=> $b} keys %$pbdata; 
  my ($bd, $section, $score, $mp_ns, $mp_ew, $pair_num_ns, $id, $declarer, $ddix, $ddixseat);
  my ($contract, $contractresult, $lead, $leadCheck);
  # Avoid warning when processing BAM because $evt->{'movement'} will not be defined.
  my $isHowell = defined $evt->{'movement'} && $evt->{'movement'} eq 'ONE WINNER';

  # Determine the first section. Used when there is only one section.
  my @allSections = keys %$sections; my $singleSection = $allSections[0];

  for my $bnum (@bnums) {
    my @results = @{$$pbdata{$bnum}};
    my $gibdd = $phd->{$bnum}{'dd'};
    
    for my $i (0..$#results) {
      ($score = $results[$i]{'ns_score'}) =~ s/\s+//g;
      $score = 0 if $score eq 'PASS';
      # $mp_ew is nearly always top - $mp_ns but need to handle split scores.
      # Quote pair identifiers so that the JSON output will consistently treat them
      # as strings even if they are numeric because there is only one session.
      # Coerce numeric values to unquoted in JSON output with 0 +
      my @vals = ($score =~ /\|/ ? $score : 0 + $score,
        0 + $results[$i]{'mp_ns'}, 0 + $results[$i]{'mp_ew'}, 
        qq($results[$i]{'pair_id_ns'}) . ($isHowell ? '' : 'N'),
        qq($results[$i]{'pair_id_ew'}) . ($isHowell ? '' : 'E') );
      if ($bwsHasConts || $bwsHasLeads) {
        ($section, $pair_num_ns) = $results[$i]{'pair_id_ns'} =~ /([A-Z]*)(\d+)/;
        # If pair numbers are not prefixed by a section, then it is a one section event.
        $section = $singleSection if !$section;
        if (exists $bsc->{$section}) { $id = $bsc->{$section}->{'ID'}; } else { $id = 0; }

        if ($bwsHasConts) {
          $contract = $bws->{$id}{$bnum}{$pair_num_ns}{'Contract'};
          if (!$contract) {
            push @vals, '', '', '', '', undef;
            # Typically have an empty string for $CONTRACT when the board is not played
            # because there the pair was too slow. Can also have an empty string if
            # pairs are assigned AVE, AVE+, or AVE-.
          }
          elsif ($contract eq 'PASS') {
            push @vals, 'PASS', '', '', '', undef;
          }
          else {
            substr($contract,2,3) = 'N' if substr($contract,2,2) eq 'NT';
            $contract =~ tr/x/*/; $contract =~ s/\s//g;
            push @vals, 0 + substr($contract,0,1), substr($contract,1);
            
            $contractresult = $bws->{$id}{$bnum}{$pair_num_ns}{'Result'};
            $contractresult = 0 if $contractresult eq '=';
            $declarer = $bws->{$id}{$bnum}{$pair_num_ns}{'NS/EW'};
            push @vals, $declarer, 0 + $contractresult;
          
            if (! defined $gibdd) { push @vals, undef; }
            else {
              # Compute the Extra Trick Factor (ETF), how many tricks better worse than
              # the double dummy expectation that declarer achieved.
              ($ddix = substr($contract,1,1)) =~ tr/NSHDC/01234/; $ddix <<= 2;            
              ($ddixseat = $declarer) =~ tr/ENWS/0123/;
              $ddix += $ddixseat;
              # $vals[5] + $vals[8] = Contract level + tricks taken relative to level.
              # Double dummy values are tricks that N-S can take even if E-W is declaring.
              push @vals, $vals[5] + $vals[8] + (($ddixseat % 2) ?
                6 - hex(substr($gibdd,$ddix,1)) : hex(substr($gibdd,$ddix,1)) - 7);
            }
          }
        }
          
        if ($bwsHasLeads) {
          $lead = $bws->{$id}{$bnum}{$pair_num_ns}{'LeadCard'};
          $leadCheck = $bws->{$id}{$bnum}{$pair_num_ns}{'LeadCheck'};
          if (!$lead) { push @vals, ''; }
          else {
            substr($lead,1,2) = 'T' if substr($lead,1) eq '10';
            if ($leadCheck eq 'opp') { $lead .= '='; }
            elsif ($leadCheck eq 'wrong') { $lead .= '?'; }
            push @vals, $lead;
          }
        }
      }
      $bd->{$bnum}{'results'}[$i] = \@vals;
    }
  }
  
  # Package deals for each hand.
  if (defined $phd) {
    for my $bnum (@bnums) {
      if (!defined $phd->{$bnum}) { next; }
      $bd->{$bnum}{'deal'} =  'W:' . join(' ', $phd->{$bnum}{'west'},
        $phd->{$bnum}{'north'}, $phd->{$bnum}{'east'}, $phd->{$bnum}{'south'});
      $bd->{$bnum}{'gibdd'} = $phd->{$bnum}{'dd'} if defined $phd->{$bnum}{'dd'};
      foreach my $fd ('parNS', 'parEW', 'parContracts', 'totalTricks', 'totalTrumps') {
        $bd->{$bnum}{$fd} = $phd->{$bnum}{$fd} if defined $phd->{$bnum}{$fd};
      }
    }
  }
  
  my $data = {'creator' => 'ACBLmerge ' . $VERSTR, 'version' => $DATAMINING_FORMAT_VERSION,
    'event' => $evt, 'pairs' => $ppy, 'boards' => $bd};
  if ($isBAM) { $data->{'teams'} = $ppy; } else { $data->{'pairs'} = $ppy; }  
  if (! open(JOUT, '>', $dmfname)) {
    print STDERR "Unable to open/write: $dmfname\n"; exit($EXIT_FILE_ERR);
  }
  print JOUT JSON::PP->new->encode($data);
  close(JOUT);  
}

sub dmJSONteams {
  # Dumps information about the event and the teams and the individual player awards
  # in JSON format.
  if (scalar(@_) != 6) { die "function requires 6 arguments."; }
  my ($dmfname, $evt, $pyteams, $pl, $pnn, $fsdata) = @_;
  requirePackage('JSON::PP', 'Creating JSON data mining file');
  
  if ($fsdata) { $evt->{'fs'} = $fsdata; }
  my %pyteams2;
  foreach my $teamnum (keys %$pyteams) {
    $pyteams2{$teamnum}{'players'} = [ @{$pyteams->{$teamnum}} ];
  }
  if ($pnn) {
    foreach my $playername (keys %$pl) {
      if ( !defined $pl->{$playername}{'pnum'} ) {
        $pl->{$playername}{'pnum'} = $pnn->{$playername};
      }
    }
  }
  my $data = {'event' => $evt, 'teams' => \%pyteams2, 'players', $pl};
  if (! open(JOUT, '>', $dmfname)) {
    print STDERR "Unable to open/write: $dmfname\n"; exit($EXIT_FILE_ERR);
  }
  print JOUT JSON::PP->new->encode($data);
  close(JOUT);  
}

sub JSwindowname {
  # Set window name to URL. Used for board number navigation on popup recap.
  print OUT '<script type="text/javascript">', 
    'window.name = window.location.origin + window.location.pathname;</script>', "\n\n";
}

sub JSoptions {
  # Include program invocation options needed by other JavaScript functions.
  my $americanstyle = defined $opt{'americanstyle'} ? 1 : 0;
  print OUT <<"DONE"
<script type="text/javascript">
function options() {
  return { americanstyle: $americanstyle };
}
</script>

DONE
}

sub JSredirect {
  # Generate Javascript code to automatically redirect to the iPhone
  # version of the webpage if an iPhone or iPod touch browser client
  # is detected.
  my ($iphfname) = @_;
  (my $bname = $iphfname) =~ s/.*[\\\/]//;
  print OUT <<"DONE";
<script type="text/javascript">
if ((navigator.userAgent.indexOf('iPhone') != -1) ||  
    (navigator.userAgent.indexOf('iPod') != -1)) {  
  document.location = "$bname";  
}
</script>
DONE
}

sub JSheader {
  # Add JavaScript code to the output file.
  #
  # Note: As mentioned in the HTML 4 Recommendations note about specifying
  # non-HTML data in element content, end tags are recognized within SCRIPT
  # elements, but other kinds of markup--such as start tags and comments--
  # are not. This is an unintuitive quirk of SGML for elements defined to
  # have CDATA content. The workaround is to escape the closing forward
  # slash with a backslash in parts of ACBLmergeCommon.js. Learn more at
  # the following URL:
  # 
  # http://www.htmlhelp.com/tools/validator/problems.html#script
  my ($gametype) = @_;
  if (scalar(@_) != 1) { die "function requires 1 argument."; }
  if (ref($gametype) ne '' || ($gametype ne 'pairs' && $gametype ne 'teams')) {
    die("First argument (GAMETYPE) must be 'pairs' or 'teams'");
  }

  my $jsfnamePairs  = $SCRIPTPATH . 'ACBLmergePairs.js';
  my $jsfnameCommon = $SCRIPTPATH . 'ACBLmergeCommon.js';
  if (!-f $jsfnameCommon) {
    print STDERR "Missing application file: $jsfnameCommon\n"; exit($EXIT_FILE_ERR);
  }
  if (!-f $jsfnamePairs && $gametype eq 'pairs') {
    print STDERR "Missing application file: $jsfnameCommon\n"; exit($EXIT_FILE_ERR);
  }

  print OUT "\n", '<script type="text/javascript">', "\n";

  if ($gametype eq 'pairs') {
    insertFile($jsfnamePairs);
    print OUT "\n";
  }
  insertFile($jsfnameCommon);

  print OUT '</script>', "\n\n";
}

sub JSvars {
  if (scalar(@_) != 8) { die "function requires 8 arguments."; }
  my ($evt, $singleSection, $ppy, $pbdata, $bsc, $bws, $bwsHasConts, $bwsHasLeads) = @_;
  my %py = %$ppy; my %bdata = %$pbdata;
  my $issuedWarning, my $totalMissingContracts = 0;
  
  # Note: JavaScript does not have associative arrays (there is a kludge based
  # on the object syntax but it is dangerous and we will avoid it here). So just
  # pack the keys and value(s) adjacent and deal with the inefficient "key lookups"
  # in JavaScript. The arrays are not that large so it should not create a big
  # performance issue.
  
  # Uses Here Document notation (see http://en.wikipedia.org/wiki/Heredoc)
  print OUT <<'DONE';
<script type="text/javascript">
function pairdata() {
DONE

  my $isfirst = 1; my $str = '';
  if ($evt->{'gametype'} ne 'BAM') {
    foreach my $pair_id (sort keys %py) {
      if (!$isfirst) { $str .= ','; } else {$isfirst = 0;}
      $str .= join(',', (dqjsesc($pair_id), dqjsesc($py{$pair_id}{'player1'}),
        dqjsesc($py{$pair_id}{'player2'}) ) );
    }
  }
  print OUT "  p = [$str];\n";

  print OUT <<'DONE';
  return p;
}

DONE

  # This JavaScript function returns three arrays. HANDIX is the hand index,
  # indicating what board number is stored in the corresponding location of
  # the BTOP and B arrays. Normally, it is just 1..N and seems kind of redundant
  # but it gives the ability to deal with arbitrary board numbers without 
  # creating filler elements in BTOP and B. BTOP is the top MP value on a
  # board (#times played - 1). B packs the board results.
  print OUT <<'DONE';
function boarddata() {
DONE

  my @bnums = sort {$a <=> $b} keys %bdata;
  
  my (@times_played, $bstr, $bnum);
  my ($section, $pair_num_ns, $id, $contract, $contractresult, $lead, $leadCheck);
  
  for my $ix (0..$#bnums) {
    my $bbstr;
    $bnum = $bnums[$ix];
    my @results = @{$bdata{$bnum}};
    push @times_played, $#results + 1;

    for my $i (0..$#results) {
      if ($i > 0) { $bbstr .= ','; }
      my $score = $results[$i]{'ns_score'};
      # Add double qoutes around non-numeric scores (AVE, AVE+, AVE-, etc).
      if ($score !~ /^-*\d+$/) { $score = dqjsesc($score); }
      my @vals = ($score, $results[$i]{'mp_ns'}, dqjsesc($results[$i]{'pair_id_ns'}),
        dqjsesc($results[$i]{'pair_id_ew'}) );
      if ($bwsHasConts || $bwsHasLeads) {
        ($section, $pair_num_ns) = $results[$i]{'pair_id_ns'} =~ /([A-Z]*)(\d+)/;
        # If pair numbers are not prefixed by a section, then it is a one section event.
        $section = $singleSection if !$section;
        if (exists $bsc->{$section}) { $id = $bsc->{$section}->{'ID'}; } else { $id = 0; }

        if ($bwsHasConts) {
          $contract = $bws->{$id}{$bnum}{$pair_num_ns}{'Contract'};
          if (!$contract) {
            push @vals, '""';
            # Typically have an empty string for $CONTACT when the board is not played
            # because there was no time. Can also happen if pairs are assigned AVE, AVE+,
            # or AVE-. Checking for PASS works around bug in Bridgemate communication
            # with ACBLscore.
            if (!defined $contract || ($score ne '"PASS"' && $score !~ /AVE/) ) {
              $totalMissingContracts++;
              if (!$issuedWarning && !$opt{'quiet'}) {
                print STDERR "Warning: Missing contract for board $bnum with " . 
                  "pair $pair_num_ns seated N-S in section $section.\n";
                $issuedWarning = 1;
              }
            }
          }
          elsif ($contract eq 'PASS') {
            push @vals, dqjsesc('PASS');
          }
          else {
            substr($contract,1,1) = '';
            substr($contract,1,2) = 'N' if substr($contract,1,2) eq 'NT';
            $contract =~ s/ xx/**/;
            $contract =~ s/ x/*/;
            $contractresult = $bws->{$id}{$bnum}{$pair_num_ns}{'Result'};
            $contractresult = '' if $contractresult eq '=';
            $contract .= ' ' . $bws->{$id}{$bnum}{$pair_num_ns}{'NS/EW'};
            $contract .= ' ' . $contractresult if $contractresult;
            push @vals, dqjsesc($contract);
          }
        }
          
        if ($bwsHasLeads) {
          $lead = $bws->{$id}{$bnum}{$pair_num_ns}{'LeadCard'};
          $leadCheck = $bws->{$id}{$bnum}{$pair_num_ns}{'LeadCheck'};
          # Don't worry about issuing a warning. If the BWS file is wrong, it will get flagged
          # by the lack of a contract as above.
          if (!$lead) { push @vals, '""'; }
          else {
            substr($lead,1,2) = 'T' if substr($lead,1) eq '10';
            if ($leadCheck eq 'opp') { $lead .= '='; }
            elsif ($leadCheck eq 'wrong') { $lead .= '?'; }
            push @vals, dqjsesc($lead);
          }
        }
      }
      $bbstr .= join(',', @vals);
    }
    if ($ix > 0) { $bstr .= ",\n"; }
    $bstr .= "[$bbstr]";
  }
  
  print OUT "  var hasContracts=", $bwsHasConts, ";\n";
  print OUT "  var hasLeads=", $bwsHasLeads, ";\n";
  # Note: for IMP Pairs, there is not top matchpoint score.
  print OUT "  var top=", $evt->{'top'} ? $evt->{'top'} : 'undefined', ";\n";
  print OUT "  var handix=[", join(',', @bnums), "];\n";
  print OUT "  var times_played=[", join(',', @times_played), "];\n";
  print OUT "  var b=[\n$bstr\n];\n";

  print OUT <<'DONE';
  return [top, handix, times_played, hasContracts, hasLeads, b];
}
</script>

DONE
  
  if ($totalMissingContracts && !$opt{'quiet'}) {
    my $plural = $totalMissingContracts == 1 ? '' : 's';
    print STDERR <<"DONE";
Missing $totalMissingContracts contract$plural. If this number is large you may have supplied the
wrong Bridgemate / BridgePad file.
DONE
  }
}

sub CSSheader {
  if (scalar(@_) != 1) { die "function requires 1 argument."; }
  my ($gametype) = @_;
  if ($gametype ne 'pairs' && $gametype ne 'teams') {
    die "Unknown game type: $gametype";
  }
  
  # Generate CSS to control document appearance.
  my $cssfnameCommon = $SCRIPTPATH . 'ACBLmergeCommon.css';
  my $cssfnamePairs  = $SCRIPTPATH . 'ACBLmergePairs.css';
  if (!-f $cssfnameCommon) {
    print STDERR "Missing application file: $cssfnameCommon\n"; exit($EXIT_FILE_ERR);
  }
  if ($gametype eq 'pairs' && !-f $cssfnamePairs) {
    print STDERR "Missing application file: $cssfnamePairs\n"; exit($EXIT_FILE_ERR);
  }

  print OUT <<'DONE';
  
<style type="text/css">
DONE

  insertFile($cssfnameCommon);
  insertFile($cssfnamePairs) if $gametype eq 'pairs';
  
  print OUT <<'DONE';  
</style>

DONE
}

sub insertFile {
  # Copy content of a file to the output stream.
  my ($fname) = @_;
  
  if (!open(IN, '<:crlf', $fname)) {
    print STDERR "Unable to open/read: $fname\n"; exit($EXIT_FILE_ERR);
  }
  while (my $fline = <IN>) {
    # Go through chomp() here so that output file ends up with consistent line
    # termination (CR LF on Windows, LF on Unix, CR on Mac).
    chomp($fline);
    print OUT $fline, "\n";
  }
  
  close(IN);
}

sub dqjsesc {
  # Escapes a JavaScript string and adds double quotes around it.
  my ($str) = @_;
  $str =~ s/"/\\"/;
  $str =~ s/'/\\'/;
  return '"' . $str . '"';
}

sub sqjsesc {
  # Escapes a JavaScript string and adds single quotes around it.
  my ($str) = @_;
  $str =~ s/"/\\"/;
  $str =~ s/'/\\'/;
  return '\'' . $str . '\'';
}

sub tooltipjs {
  # Generate Javascript for player tooltip.
  my ($msg, $pnum, $name) = @_;
  if (! $msg && !$opt{'showfaces'}) { return ''; }
  return 'onmouseover="tooltip.show(' .
    join(',', ($pnum ? $pnum : 0), sqjsesc($name), sqjsesc($msg)) . ');"' .
    ' onmouseout="tooltip.hide();"';
}

sub tooltipteamjs {
  # Generate Javascript for team tooltip.
  my ($teamnum, $pynames, $teamMP, $showMP) = @_;

  my @pnames = @{$pynames->{$teamnum}};
  my $msg = join('<br>', @pnames);
  if ( $teamMP->{$teamnum}{'mean'} && $showMP ) {
    my $mpinfo = sprintf('Average MP: %d<br>Geomean MP: %d<br>Seed Rank: %d',
      $teamMP->{$teamnum}{'mean'}, $teamMP->{$teamnum}{'geomean'},
      $teamMP->{$teamnum}{'seedgeorank'});
    $msg .= '<br><br>' . $mpinfo;
  }

  return 'onmouseover="tooltip.show(' . 
    join(',', 0, '\'\'', sqjsesc($msg)) . ');"' .
    ' onmouseout="tooltip.hide();"';
}

sub appDir {
  # Returns the user's application directory for ACBLmerge.
  my $dname = defined $opt{'appdir'} ? $opt{'appdir'} :
    ($^O eq 'MSWin32') ? $ENV{'APPDATA'} . '\\ACBLmerge\\' : $ENV{'HOME'} . '/.ACBLmerge/';
  if (!-d $dname && !mkdir($dname)) {
    print STDERR "Unable to create per user application directory: $dname\n";
    exit($EXIT_MAKE_APPDIR_FAIL);
  }
  return($dname);
}

sub requirePackage {
  # FUNCTIONALTY - Optional description of software functionality requiring the package.
  my ($packageName, $functionality) = @_;

  eval "require $packageName";
  if ($@) {
    if ($^O ne 'MSWin32') {
      print STDERR <<"DONE";
$functionality
requires the $packageName Perl package.
Please install it. Automatic package installation is only provided for the
ActiveState distribution on Windows. If you have CPAN installed, the following
command might work:

  cpan -i $packageName  

DONE
      exit($EXIT_NEED_PERL_PACKAGE);
    }
    
    my $cmd = "ppm install $packageName";

    if (! $opt{'quiet'}) {
      print STDERR <<"DONE";
$functionality
requires the $packageName Perl package.
Trying to install this package (and any dependencies) automatically
using the ActivePerl Perl Package Manager (PPM) ...

  Executing: $cmd

Package installation could take a couple of minutes.

DONE
    }

    my $result = system($cmd);
    
    eval "require $packageName";
    if ($@) {
      print STDERR <<"DONE";
Attempt to install $packageName Perl package failed. Possible reasons
include: (1) Unable to install to Perl package area (you may need
Administrator permissions), (2) PPM is not on the System search path,
(3) Using Strawberry Perl instead of ActiveState Perl, or (4) there is
no network connection. The error code returned from executing
\"$cmd\" was: $result.

Try installing the $packageName Perl package manually.
   
DONE
      exit($EXIT_NEED_PERL_PACKAGE);
    }
  }
}
